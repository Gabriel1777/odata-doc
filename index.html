<!DOCTYPE html>
<html>
<head lang="es">
	<title>Laravel OData</title>
	<link rel="icon" href="images/laravel.png">
	<link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet"/>
	<link href="https://fonts.googleapis.com/css?family=Open+Sans&display=swap" rel="stylesheet"/>

	<!-- Robot -->
	<link rel="preconnect" href="https://fonts.googleapis.com">
	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link href="https://fonts.googleapis.com/css2?family=Roboto:ital,wght@0,100;0,300;0,400;1,100;1,300;1,400&display=swap" rel="stylesheet">

	<!-- Lato -->
	<link rel="preconnect" href="https://fonts.googleapis.com">
	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link href="https://fonts.googleapis.com/css2?family=Lato:ital,wght@0,100;0,300;0,400;1,100;1,300&family=Roboto:ital,wght@0,100;0,300;0,400;1,100;1,300;1,400&display=swap" rel="stylesheet">

	<!-- Rubik -->
	<link rel="preconnect" href="https://fonts.googleapis.com">
	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link href="https://fonts.googleapis.com/css2?family=Lato:ital,wght@0,100;0,300;0,400;1,100;1,300&family=Roboto:ital,wght@0,100;0,300;0,400;1,100;1,300;1,400&family=Rubik:ital,wght@0,300;0,400;0,500;1,300;1,400&display=swap" rel="stylesheet">

	<!-- Nunito -->
	<link rel="preconnect" href="https://fonts.googleapis.com">
	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link href="https://fonts.googleapis.com/css2?family=Lato:ital,wght@0,100;0,300;0,400;1,100;1,300&family=Nunito:ital,wght@0,200;0,300;0,400;0,500;1,200;1,300;1,400&family=Roboto:ital,wght@0,100;0,300;0,400;1,100;1,300;1,400&family=Rubik:ital,wght@0,300;0,400;0,500;1,300;1,400&display=swap" rel="stylesheet">


	<link rel="stylesheet" href="css/app.css"/>
	<link rel="stylesheet" href="css/dark.css"/>
	<link rel="stylesheet" href="css/code.css"/>
</head>
<body>
	<main id="my-app">
		<aside class="left-panel">

			<div class="panel-header">
				<div class="container-logo">
					<img src="images/laravel.png" class="laravel-logo"/>
					<span class="logo-divider">+</span>
					<img src="images/odata.png" class="odata-logo"/>
				</div>
				<div class="container-title">
					<h1 class="header-title">Laravel/OData</h1>
				</div>
			</div>

			<div class="panel-body">
				<ul>
					<li class="top-item active1"> 
						<a href="#"> 
							<span class="item-icon">#</span> Introducción
						</a>
					</li>
					<li class="top-item"> 
						<a href="#"> 
							<span class="item-icon">#</span> Instalación
						</a>
					</li>
					<li class="top-item"> 
						<a href="#"> 
							<span class="item-icon">#</span> Integración
						</a>
						<ul>
							<li>
								<a href="#">
									<span class="item-icon">○</span>Cargar metodos
								</a>
							</li>
							<li>
								<a href="#">
									<span class="item-icon">○</span>Crear controladores
								</a>
							</li>
							<li>
								<a href="#">
									<span class="item-icon">○</span>Uso
								</a>
							</li>
						</ul>
					</li>
					<li class="top-item"> 
						<a href="#"> 
							<span class="item-icon">#</span> Transformadores
						</a>
						<ul>
							<li>
								<a href="#">
									<span class="item-icon">○</span>Usando modelos
								</a>
							</li>
							<li>
								<a href="#">
									<span class="item-icon">○</span>Usando clases
								</a>
							</li>
							<li>
								<a href="#">
									<span class="item-icon">○</span>Usando Laravel/fractal
								</a>
							</li>
						</ul>
					</li>
					<li class="top-item"> 
						<a href="#"> 
							<span class="item-icon">#</span> Consultas por defecto
						</a>
					</li>
					<li class="top-item"> 
						<a href="#"> 
							<span class="item-icon">#</span> Serializador
						</a>

						<ul>
							<li>
								<a href="#">
									<span class="item-icon">○</span>Usando modelos
								</a>
							</li>
							<li>
								<a href="#">
									<span class="item-icon">○</span>Usando clases
								</a>
							</li>
						</ul>
					</li>

					<li class="top-item">
						<a href="#">
							<span class="item-icon">#</span> Paginación
						</a>
					</li>

					<li class="top-item"> 
						<a href="#"> 
							<span class="item-icon">#</span> Filtros
						</a>

						<ul>
							<li>
								<a href="#">
									<span class="item-icon">○</span>Condicional igual que
								</a>
							</li>
							<li>
								<a href="#">
									<span class="item-icon">○</span>Condicional deferente de
								</a>
							</li>
							<li>
								<a href="#">
									<span class="item-icon">○</span>Condicional like
								</a>
							</li>
							<li>
								<a href="#">
									<span class="item-icon">○</span>Condicional mayor que
								</a>
							</li>
							<li>
								<a href="#">
									<span class="item-icon">○</span>Condicional menor que
								</a>
							</li>
							<li>
								<a href="#">
									<span class="item-icon">○</span>Condicional In
								</a>
							</li>

							<li>
								<a href="#">
									<span class="item-icon">○</span>Usando and
								</a>
							</li>

							<li>
								<a href="#">
									<span class="item-icon">○</span>Usando or
								</a>
							</li>
						</ul>
					</li>

					<li class="top-item"> 
						<a href="#"> 
							<span class="item-icon">#</span> Separando filtros
						</a>

						<ul>
							<li>
								<a href="#">
									<span class="item-icon">○</span>Usando select
								</a>
							</li>
						</ul>
					</li>

					<li class="top-item"> 
						<a href="#"> 
							<span class="item-icon">#</span> Consultas anidadas
						</a>

						<ul>
							<li>
								<a href="#">
									<span class="item-icon">○</span>Inner joins
								</a>
							</li>

							<li>
								<a href="#">
									<span class="item-icon">○</span>Usando alias
								</a>
							</li>
						</ul>
					</li>

					<li class="top-item"> 
						<a href="#"> 
							<span class="item-icon">#</span> Manejando datos
						</a>

						<ul>
							<li>
								<a href="#">
									<span class="item-icon">○</span>OrderBy
								</a>
							</li>

							<li>
								<a href="#">
									<span class="item-icon">○</span>OrderByDesc
								</a>
							</li>

							<li>
								<a href="#">
									<span class="item-icon">○</span>First
								</a>
							</li>

							<li>
								<a href="#">
									<span class="item-icon">○</span>Auth User
								</a>
							</li>
						</ul>
					</li>

					<li class="top-item"> 
						<a href="#"> 
							<span class="item-icon">#</span> Exportando datos
						</a>
						<ul>
							<li>
								<a href="#">
									<span class="item-icon">○</span>Usando laravel excel
								</a>
							</li>
						</ul>
					</li>

					<li class="top-item"> 
						<a href="#"> 
							<span class="item-icon">#</span> Modo personalizado
						</a>
					</li>
				</ul>
			</div>

		</aside>

		<div class="doc-main">

			<h1 class="big-logo-title">Laravel/OData V1</h1>
			<div class="big-container-logo">
				<img src="images/laravel.png" class="laravel-logo"/>
				<span class="logo-divider">+</span>
				<img src="images/odata.png" class="odata-logo"/>
			</div>
			<article>
				<br/>
				<h1> <span class="item-icon">#</span> Introducción</h1>
				Protocolo de datos Abiertos para Laravel
				<br/>
				<span class="label">Laravel/OData</span> es un paquete que implementa el protocolo de datos abierto en Laravel 5.8 o superior.
				<br/>
				<span class="label">OData</span> es la mejor forma de implementar <span class="label">API REST</span> en las aplicaciones, es usado por Microsoft en su lenguaje de programación C#. define un conjunto de mejores practicas a la hora de construir una API para que los desarroladores se concentren en la lógica comercial y así poder olvidarse de las preocupaciones por códigos de estado HTTP, convenciones de url, manejo de consultas y demas. <a href="https://www.odata.org/" target="_blank" class="article-link">https://www.odata.org/</a> <br/>
				Este paquete expone una serie de funciones usadas por OData pero adaptadas a la metodologia que usa laravel, para exponer modelos, usar filtros , manejar consultas y demas usando <span class="label">Eloquent</span>.
				<br/>
				Las ventajas que se obtienen al usar un protocolo de datos abiertos a la hora de contruir <span class="label">API Rest</span> es que este agiliza el desarrolo en el backend al evitar el uso de consultas complejas y super anidadas en los controladores, ademas de que esto mantiene limpio los controladores de logica super extensa que daña las buenas practicas al violar el principio de que los modelos deben mantener la logica de negocio y los controladores solo deben devolver datos.
				<br/>
				OData te permite exponer un modelo atravez de un controlador y de esta manera te olvidas de todas las posibles consultas que pueden salir apartir de ese modelo, ya que es posible solicitarle a la API que filtre los datos expuestos por el modelo por uno o varios campos. usando condicionales <span class="label">and</span> u <span class="label">or</span> de está manera se evita tener que programar cada una de las funciones que expone un sistema que pueden llegar a ser muchas.
				<br/>
				tome como ejemplo un modelo de usuarios <span class="label"> App\User</span> este expone las siguientes consultas en su sistema:
				<br/>
				<span class="label circle">○</span> Lista de usuarios.<br/>
				<span class="label circle">○</span> Lista de usuarios que pertenecen a un pais.<br/>
				<span class="label circle">○</span> Lista de usuarios que pertenecen a una ciudad.<br/>
				<span class="label circle">○</span> Lista de usuarios que se registrarón este mes.<br/>
				<span class="label circle">○</span> Lista de usuarios que pertenecen a cierto rol.<br/>
				entre otras ...<br/>
				normalmente usted puede pensar en crear un <span class="label">Endpoint</span> por cada consulta, o filtrar manualmente los usuarios desde una unica ruta basandose en los diferentes parámetros que se le envían a travez de la url.
				<br/>
				uno de los problemas que se tienen al hacer esto es que usted mismo deberá programar la logica para cada consulta ademas de que si tiene un número bastante amplio de consultas solo para el modelo de usuarios. tratar de poner toda la logica en un solo controlador no escala y dañará las practicas de su código al asignar logica demasiado extensa a un controlador.
				<br/>
				Si decide optar por la solución de poner la lógica de cada consulta en una ruta diferente esto solucionará el problema de las malas practicas en sus controladores, pero de igual forma si tiene muchas consultas tendrá un número grande de rutas solo para consultar un solo modelo, en este caso el <span class="label">App\User</span>.
				<br/>
				Con el <span class="label">OData</span> solo tendrá que exponer su modelo <span class="label">App\User</span> o cualquier otro desde un unico controlador y la aplicación o las aplicaciones que consumen está api pueden solicitarle diferentes consultas al modelo de usuarios usando unicamente parámetros por url. de esto se trata el <span class="label">OData</span>, de una <span class="label">API Rest</span> que solamente expone recursos en este caso <span class="label">Modelos</span> y de está manera los desarrolladores solo tienen que preocuparse por consumir los recursos y construir su aplicación en el front.
				<br/>
				Ademas el <span class="label">OData</span> se encarga de otros procesos comunes en las API, como paginación, alinemiento de datos, exportación de datos, relationships, consultas multitabla entre otros ...
				<br/>
			</article>
			<article>
				<h1> <span class="item-icon">#</span> Instalación</h1>
				Para instalar el paquete puede hacerlo usando composer ejecutando el siguiente comando desde su terminal:
				<div class="cmd-code">composer require apilaravelodata/odata</div>
				una vez instalado el paquete asegurese de tener migradas sus tablas en la base de datos:
				<div class="cmd-code">php artisan migrate</div>
				una vez que ya tenga migradas las tablas en la base de datos, el paquete de <span class="label">OData</span> necesitará mapear cada una de sus tablas y almacenar cada uno de los campos en cache, esto se hace para tener un <span class="label">Esquema</span> de la base de datos en cache y evitar realizar consultas a la base de datos para verificar si existen campos que se solictan por la url, de está manera el <span class="label">OData</span> ya tiene un <span class="label">Esquema</span> en cache y puede verificar que campos son validos y cuales no los son usando procesos desde memoria. para crear el <span class="label">Esquema</span> de la base de datos en cache ejecute el siguiente comando:
				<div class="cmd-code">php artisan odata:config</div>
				Tenga en cuenta de que cada vez que modifique algúna de sus tablas agregando uno o mas campos, deberá ejecutar este comando para actualizar la cache del <span class="label">OData</span>.
				<br/>
			</article>

			<article>
				<h1> <span class="item-icon">#</span> Integración</h1>
				<h3># Cargar metodos</h3>
				El siguiente paso que debe hacer es configurar el odata para poder exponerlo desde sus controladores, para esto se recomienda usar un <span class="label">ApiController</span> controlador para su api donde incluya el uso del <span class="label">OData</span>. por ejemplo puede crear un <span class="label">app/Http/Controllers/ApiController.php</span> con el siguiente contenido:

				<div class="code-block">
					<span class="yellow-code"><xmp><?php</xmp></span>
					<div class="code-divider"></div>
					<span class="purple-code">namespace</span>
					<span class="light-code">App\Http\</span><span class="yellow-code">Controllers</span><span class="light-code">;</span>

					<div class="code-divider"></div>

					<span class="purple-code">use</span>
					<span class="yellow-code">ODataResponse</span><span class="light-code">;</span>

					<div class="code-divider"></div>

					<span class="purple-code">class</span>
					<span class="light-code"> ApiController </span>
					<span class="purple-code">extends</span>
					<span class="green-code">Controller</span><br/>
					{
						<div class="code-padding">
							<span class="purple-code">use </span>
							<span class="yellow-code">ODataResponse</span>;
							<br/>
						</div>
					}
				</div>

				Como puede darse cuenta se trata de una simple clase que hereda a <span class="label">Controller</span> y esta implementa el trait de <span class="label">ODataResponse</span> que se encarga de cargar todos los metodos de <span class="label">OData</span> dentro de la clase.
				<br/><br/>

				<h3># Crear Controladores</h3>

				Una vez ya tenga la clase con los metodos del <span class="label">OData</span> cargados, lo siguiente que debe hacer es agregar esta clase a sus controladores para empezar a usar los metodos expuestos por el <span class="label">OData</span>. para el ejemplo usaremos un <span class="label">app/Http/Controllers/UserController.php</span> controlador con el siguiente contenido:

				<div class="code-block">
					<span class="yellow-code"><xmp><?php</xmp></span>
					<div class="code-divider"></div>

					<span class="purple-code">namespace</span>
					<span class="light-code">App\Http\</span><span class="yellow-code">Controllers</span><span class="light-code">;</span>

					<div class="code-divider"></div>

					<span class="purple-code">use </span>App\Http\Controllers\<span class="yellow-code">ApiController</span>;

					<div class="code-divider"></div>

					<span class="purple-code">class</span>
					<span class="light-code"> UserController </span>
					<span class="purple-code">extends</span>
					<span class="green-code">ApiController</span><br/>
					{
						<div class="code-padding">
							<span class="comment-code">// ...</span>
						</div>
					}
				</div>

				<h3># Uso</h3>

				Ahora simplemente dentro del controlador creamos un metodo index que retorna un <span class="label">odataJsonResponse</span> basado en un modelo de <span class="label">Eloquent</span>.

				<div class="code-block">
					<span class="yellow-code"><xmp><?php</xmp></span>
					<div class="code-divider"></div>

					<span class="purple-code">namespace</span>
					<span class="light-code">App\Http\</span><span class="yellow-code">Controllers</span><span class="light-code">;</span>

					<div class="code-divider"></div>

					<span class="purple-code">use </span>App\Models\<span class="yellow-code">User</span>;
					<div class="code-divider"></div>
					<span class="purple-code">use </span>App\Http\Controllers\<span class="yellow-code">ApiController</span>;

					<div class="code-divider"></div>

					<span class="purple-code">class</span>
					<span class="light-code"> UserController </span>
					<span class="purple-code">extends</span>
					<span class="green-code">ApiController</span><br/>
					{
						<div class="code-padding">
							<span class="purple-code">public function </span> index <span class="code-sign">( )</span> <br/>
							{
								<div class="code-padding">
									<span class="purple-code">return </span>
									<span class="blue-code">$this</span><span class="code-sign">-></span><span class="yellow-code">odataJsonResponse</span><span class="code-sign">(</span>
									<span class="purple-code">new </span><span class="code-sign">User</span>( )<span class="code-sign"> )</span>;
								</div>
							}
						</div>
					}
				</div>

				Por ultimo es importante que establesca la propiedad <span class="label">table</span> dentro de su modelo como <span class="label">public</span>. esta propiedad la usa el <span class="label">OData</span> para identificar la tabla a la cual hace referencia el modelo.

				<div class="code-block">
					<span class="comment-code">// ...</span>
					<div class="code-divider"></div>
					<span class="purple-code">class</span> <span class="yellow-code">User</span> <span class="purple-code">extends</span> <span class="green-code">Model</span>
					{
						<div class="code-padding">
							<span class="comment-code">// ...</span><br/>
							<span class="purple-code">public</span> <span class="blue-code">$table</span> <span class="code-sign">=</span> <span class="green-code">"users"</span>;
						</div>
					} <br/>
				</div>

				Listo, esto es lo que necesitamos para implementar el <span class="label">OData</span> en una aplicación de laravel. lo siguiente que debe hacer es crear una ruta que apunte al metodo index de tu controlador y una vez realices una solicitud HTTP a esta ruta el <span class="label">OData</span> ya se encargará de generar la estructura de la respuesta en json, el código de estado HTTP junto con la colección de datos. un ejemplo de respuesta sería esta:

				<div class="code-block">
					{
						<div class="code-padding">
							<span class="green-code">"data"</span> : [
							<div class="code-padding">
								<span class="green-code">"data"</span> : [
									<div class="code-padding">
										{
											<div class="code-padding">
												<span class="green-code">"id"</span> : <span class="code-sign">1</span>,<br/>
												<span class="green-code">"name"</span> : <span class="green-code">"example user"</span><br/>
												<span class="comment-code">// ...rest</span>
											</div>
										}, <br/>
										{
											<div class="code-padding">
												<span class="green-code">"id"</span> : <span class="code-sign">2</span>,<br/>
												<span class="comment-code">// ...rest</span>
											</div>
										}
									</div>
								], <br/>
								<span class="green-code">"length"</span> : <span class="code-sign">2</span> <span class="comment-code">// número de registro en la colección</span>
							</div>
							],<br/>
							<span class="green-code">"code"</span> : <span class="yellow-code">200</span>
						</div>
					}
					</span>
				</div>

				Esta es la estructura que por defecto se devolverá para serializar las respuestas de la API, si desea modificarla puede obtener el resultado que devuelve el <span class="label">odataJsonResponse</span> y luego armar un array con base en los valores que obtuvo. y de está manera puede agregar propiedades adicionales que necesite retornar en cada una de las repuestas de su API.
				<br/>
				Otra opción que tiene es usar el metodo <span class="label">odataModelCollection</span> que devuelve la coleción de datos del modelo, igualmente esta coleción toma los filtros que se le indiquen a la <span class="label">API</span> por la url. esto lo puede usar para personalizar la respuesta de su api pero mantienendo el uso del <span class="label">OData</span> en su modelo. también puede agregarle a su respuesta el <span class="label">odataProperties</span> metodo que se encarga de devolver un array con los valores de la respuesta como: código de estado HTTP, cantidad de datos encontrados en la respuesta y demas.

				<div class="code-block">
					<span class="yellow-code"><xmp><?php</xmp></span>
					<div class="code-divider"></div>

					<span class="purple-code">namespace</span>
					<span class="light-code">App\Http\</span><span class="yellow-code">Controllers</span><span class="light-code">;</span>

					<div class="code-divider"></div>

					<span class="purple-code">use </span>App\Models\<span class="yellow-code">User</span>;
					<div class="code-divider"></div>
					<span class="purple-code">use </span>App\Http\Controllers\<span class="yellow-code">ApiController</span>;

					<div class="code-divider"></div>

					<span class="purple-code">class</span>
					<span class="light-code"> UserController </span>
					<span class="purple-code">extends</span>
					<span class="green-code">ApiController</span><br/>
					{
						<div class="code-padding">
							<span class="purple-code">public function </span> index <span class="code-sign">( )</span> <br/>
							{
								<div class="code-padding">
									<span class="purple-code">return </span> [
										<div class="code-padding">
											<span class="green-code">"collection"</span> <span class="yellow-code"> => </span>
											<span class="blue-code">$this</span><span class="code-sign">-></span><span class="yellow-code">odataModelCollection</span><span class="code-sign">(</span>
											<span class="purple-code">new </span><span class="code-sign">User</span>( )<span class="code-sign"> )</span>,<br/>
											<span class="green-code">"api_info"</span> <span class="yellow-code"> => </span>
											<span class="blue-code">$this</span><span class="code-sign">-></span><span class="yellow-code">odataProperties</span><span class="code-sign">(</span>
											<span class="purple-code">new </span><span class="code-sign">User</span>( )<span class="code-sign"> )</span>,<br/>
											<span class="comment-code">// ...</span>
										</div>
									];
								</div>
							}
						</div>
					}
				</div>
			</article>

			<article>
				<h1> <span class="item-icon">#</span> Transformadores</h1>
				Los transformadores se usan para estructurar cada uno de los objetos que se devuelven en las colecciónes de cada una de las respuestas de la API, en el caso del modelo de usuarios el <span class="label">OData</span> por defecto devolverá la colección que devuelve laravel en sus colecciones por ejemplo al llamar un <span class="label">User::all()</span>.
				<br/><br/>
				<h3># Usando modelos </h3>
				otra caracteristica que tiene el <span class="label">OData</span> es que por defecto devolverá la coleción completa sin ningún tipo de filtro ni paginación. esto obviamente se puede solicitar desde la url, pero el punto aquí es que devolver todos los datos del modelo puede no ser lo que usted tiene planeado. por ejemplo no queremos que la contraseña del usuario se vea en la respuesta de la API, o puede que necesitemos agregar otras propiedades mas al modelo con información adicional que no necesariamente debe estar almacenada en la base de datos. <br/>
				para esto se puede usar un transformador personalizado desde el módelo, lo unico que tiene que hacer es declarar un <span class="label">transform</span> metodo dentro del modelo que devuelva un array. si el <span class="label">OData</span> detecta que existe este metodo dentro del modelo lo usará para serializar los objetos que se devuelven en la coleción de datos.
				<br/>
				esto puede ser util para asegurarse de que la respuesta devuelva unicamente los datos que usted necesita incluyendo otros datos adicionales ejemplo:

				<div class="code-block">
					<span class="comment-code">// ...</span>
					<div class="code-divider"></div>
					<span class="purple-code">class</span> <span class="yellow-code">User</span> <span class="purple-code">extends</span> <span class="green-code">Model</span><br/>
					{
						<div class="code-padding">
							<span class="comment-code">// ...</span><br/>
							<span class="purple-code">public function</span> transform <span class="code-sign">( )</span><br/>
							{
								<div class="code-padding">
									<span class="purple-code">return</span> [
										<div class="code-padding">
											<span class="green-code">"id"</span> <span class="yellow-code">=></span> <span class="blue-code">$this</span><span class="code-sign">-></span>id,<br/>
											<span class="green-code">"name"</span> <span class="yellow-code">=></span> <span class="blue-code">$this</span><span class="code-sign">-></span>name,<br/>
											<span class="green-code">"role"</span> <span class="yellow-code">=></span> <span class="blue-code">$this</span><span class="code-sign">-></span>role_id,<br/>
											<span class="green-code">"photo"</span> <span class="yellow-code">=></span> <span class="blue-code">$this</span><span class="code-sign">-></span><span class="yellow-code">getPhoto<span class="code-sign">( )</span><br/>
										</div>
									];
								</div>
							}
							<br/><span class="comment-code">// ...</span>
						</div>
					}
					<br/><span class="comment-code">// ...</span>
				</div>
				<h3># Usando clases </h3>
				Puede que la lógica de su transformador sea mucho mas robusta y necesite tener varios metodos que retornan un resultado procesado para agregarlo como una propiedad en cada uno de los objetos de la coleción. en este caso no es una buena idea asignar toda esta lógica al modelo y lo mejor es separar la lógica de la transformación de datos en una clase por separado.<br/>
				puede hacer esto creando una clase común y corriente con un metodo <span class="label">transform</span> que devuelva un array con los datos que desea mostrar por objeto, y puede usar el resto de la clase para agregar metodos que menejen y procesen la logica que necesita para las propiedades adicionales de su modelo ejemplo:

				<div class="code-block">
					<span class="purple-code">namespace </span> App\Transformers;<br/><br/>
					<span class="purple-code">class</span> <span class="yellow-code">UserTransformer</span><br/>
					{
						<div class="code-padding">
							<span class="purple-code">public function</span> getPhoto <span class="code-sign">( <span class="blue-code">$user</span> )</span><br/>
							{
								<div class="code-padding">
									<span class="comment-code">// your code ...</span>
								</div>
							}
						</div>

						<div class="code-padding">
							<span class="purple-code">public function</span> transform <span class="code-sign">( <span class="blue-code">$user</span> )</span><br/>
							{
								<div class="code-padding">
									<span class="purple-code">return</span> [<br/>
										<div class="code-padding">
											<span class="green-code">"id"</span> <span class="yellow-code"> => </span> <span class="blue-code">$user</span><span class="code-sign">-></span>id,<br/>
											<span class="green-code">"name"</span> <span class="yellow-code"> => </span> <span class="blue-code">$user</span><span class="code-sign">-></span>name,<br/>
											<span class="green-code">"role"</span> <span class="yellow-code"> => </span> <span class="blue-code">$user</span><span class="code-sign">-></span>role_id,<br/>
											<span class="green-code">"photo"</span> <span class="yellow-code"> => </span> <span class="blue-code">$this</span><span class="code-sign">-></span>getPhoto<span class="code-sign"> ( <span class="blue-code">$user</span> ),<br/>
										</div>
									];
								</div>
							}
						</div>
					}
				</div>

				Una vez ya creada la clase con la lógica del transformador deberá agregar la propiedad <span class="label">transformer</span> a su modelo para indicarle al <span class="label">OData</span> que use esta clase para serializar los objetos de la coleción que irá en la respuesta:

				<div class="code-block">
					<span class="comment-code">// ...</span><br/>
					<span class="purple-code">class</span> <span class="yellow-code">User</span> <span class="purple-code">extends</span> <span class="green-code">Model</span>
					{
						<div class="code-padding">
							<span class="comment-code">// ...</span><br/>
							<span class="purple-code">public</span> <span class="blue-code">$transformer</span> <span class="code-sign">=</span> <span class="green-code">"App\Transformers\UserTransformer"</span>;<br/>
							<span class="comment-code">// ...</span>
						</div>
					} <br/>
					<span class="comment-code">// ...</span>
				</div>

				<h3># Usando Laravel/Fractal</h3>
				<span class="label">Laravel/Fractal</span> ya ofrece una librería para transformar datos <a target="_blank" class="article-link" href="https://fractal.thephpleague.com/transformers/">https://fractal.thephpleague.com/transformers/</a>, <span class="label">Laravel/OData</span> es compatible con este caso de uso. puede agregar la propiedad <span class="label">transformer</span> igualmente en su modelo especificando en lugar de una clase común una clase de transformador.

				<div class="code-block">
					<span class="purple-code">use </span> App\Transformers\<span class="yellow-code">UserTransformer</span>;
					<div class="code-divider"></div>
					<span class="purple-code">class</span> <span class="yellow-code">User</span> <span class="purple-code">extends</span> <span class="green-code">Model</span>
					{
						<div class="code-padding">
							<span class="comment-code">// ...</span><br/>
							<span class="purple-code">public</span> <span class="blue-code">$transformer</span> <span class="code-sign">=</span> <span class="yellow-code">UserTransformer</span><span class="code-sign">::</span><span class="blue-code">class</span>;<br/>
							<span class="comment-code">// ...</span>
						</div>
					} <br/>
				</div>
			</article>

			<article>
				<h1> <span class="item-icon">#</span> Consultas por defecto </h1> 
				Conociendo que el <span class="label">OData</span> devuelve todos los datos del modelo sin nigún tipo de filtro, es lógico pensar que puede que esto no se ajuste a su caso de uso.
				puede que necesite ocultar cierta información a sus usuarios dependiendo del rol que tengan asignado, un ejemplo pordría ser las lista de ordenes donde cada usuario solo puede consultar las ordenes que ha realizado junto con su historial. y en el caso de tratarse del administrador este puede ver todas las ordenes.
				<div class="divider"></div>
				<h3># Usando un scope</h3>
				puede definir la consulta por defecto que manejará el <span class="label">OData</span> declarando un <span class="label">scope</span> dentro de su modelo, el <span class="label">scope</span> en este caso deberá llamarse <span class="label">defaultQuery</span> y este debe retornar una consulta. si el <span class="label">OData</span> detecta que este scope existe dentro del modelo, aplicará por defecto la consulta que devuelve el <span class="label">scope</span> a la colección en la respuesta de la API.

				<div class="code-block">
					<span class="purple-code">class</span> <span class="yellow-code">Order</span> <span class="purple-code">extends</span> <span class="green-code">Model</span> <br/>
					{
						<div class="code-padding">
							<span class="comment-code">// ...</span> <br/>
							<span class="purple-code">public function </span> <span class="yellow-code">scopeDefaultQuery</span> <span class="code-sign">( <span class="blue-code">$query</span> )</span> <br/>
							{
								<div class="code-padding">
									<span class="purple-code">if</span> <span class="code-sign">( <span class="light-code">auth</span>( )-><span class="light-code">user</span>( )-><span class="blue-code">isAdmin</span>( ) )</span><br/>
									{
										<div class="code-padding">
											<span class="purple-code">return </span> <span class="blue-code">$query</span>;
										</div>
									} <span class="purple-code">else</span> {
										<div class="code-padding">
											<span class="purple-code">return </span> <span class="blue-code">$query</span>-><span class="yellow-code">where</span><span class="code-sign">( <span class="green-code">"user_id"</span> <span class="light-code">, auth</span>( )-><span class="light-code">user</span>( )-><span class="light-code">id</span> )</span>;
										</div>
									}
								</div>
							}		
						</div>
					}
				</div>

				Los desarroladores que consuman su <span class="label">API</span> igualmente pueden filtrar la coleción desde la url, pero si aplico la consulta por defecto desde su modelo solo podrán filtrar los datos apartir del resultado por defecto que se le indico al <span class="label">OData</span>. no podrán deshacer el filtro por defecto desde la url, solo podrán agregar mas filtros apartir del que ya está definido.
			</article>

			<article>
				<h1> <span class="item-icon">#</span> Serializador </h1>
				Si bien usar transformadores es una buena idea para armar los objectos de la coleción en sus respuestas de la <span class="label">API</span> puede ver se en el problema de <a href="https://stackoverflow.com/questions/97197/what-is-the-n1-selects-problem-in-orm-object-relational-mapping" target="_blank" class="article-link">N+1</a> que es muy común a la hora de trabajar con un <span class="label">ORM</span>. este problema le puede causar retrazos de velocidad en las repuestas de su <span class="API">API</span> si no tiene en cuenta el número de consultas que realiza a la base de datos por cada objeto.<br/>
				si tiene una colección de 50 usuarios y en el transformador de cada objeto llama a el rol, el estado, la cuidad, el departamento y su subscripción actual, y esto lo hace por cada usuario tendrá un resultado de <span class="label">50 * 5</span> = <span class="label">250</span> consultas a su base de datos lo que puede volver lenta la respuesta de la API.<br/>
				si bien laravel ya nos ofrecen una solución usando el metodo <span class="label">with</span> que ya viene con <span class="label">Eloquent</span> y este se encarga de realizar las consultas a la base de datos necesarias para armar su colección y luego la arma desde memoria, para el ejemplo anterior esto va ir reduciendo el número de consultas de <span class="label"> 250 </span> a <span class="label">6</span>. igual debe saber que entre mas compleja sea la consulta mas dificil será de mantener usando un <span class="label">ORM</span> por lo que en casos complejos es mejor optar por utilizar <span class="label">Consultas multitabla, Vistas o Procedimientos almacenados</span>. sin embargo puede hacer uso del scope <span class="label">defaultQuery</span> del <span class="label">OData</span> para llamar el metodo with de eloquent si así lo requiere:

				<div class="code-block">
					<span class="purple-code">class</span> <span class="yellow-code">User</span> <span class="purple-code">extends</span> <span class="green-code">Model</span> <br/>
					{
						<div class="code-padding">
							<span class="comment-code">// ...</span> <br/>
							<span class="purple-code">public function </span> <span class="yellow-code">scopeDefaultQuery</span> <span class="code-sign">( <span class="blue-code">$query</span> )</span> <br/>
							{
								<div class="code-padding">
									<span class="blue-code">$query</span> = <span class="blue-code">$query</span>-><span class="yellow-code">with</span><span class="code-sign">(
										<span class="green-code">"role"</span>,
										<span class="green-code">"state"</span>,
										<span class="green-code">"city.department"</span>,
										<span class="green-code">"subscriptions"</span>
									);</span> <br/>
									<span class="purple-code">if</span> <span class="code-sign">( <span class="light-code">auth</span>( )-><span class="light-code">user</span>( )-><span class="blue-code">isAdmin</span>( ) )</span><br/>
									{
										<div class="code-padding">
											<span class="purple-code">return </span> <span class="blue-code">$query</span>;
										</div>
									} <span class="purple-code">else</span> {
										<div class="code-padding">
											<span class="purple-code">return </span> <span class="blue-code">$query</span>-><span class="yellow-code">where</span><span class="code-sign">( <span class="green-code">"user_id"</span> <span class="light-code">, auth</span>( )-><span class="light-code">user</span>( )-><span class="light-code">id</span> )</span>;
										</div>
									}
								</div>
							}		
						</div>
					}
				</div>

				<h3># Usando modelos</h3>

				Si bien el metodo <span class="label">with</span> nos ahorra el tener que hacer las consultas a la base de datos una por una y por cada objeto, esto no será util si se encuentra con una consulta compleja que relaciona muchas tablas, en estos casos tenga en cuenta que si su transformador tiene un metodo que hace 10 o mas consultas a la base de datos y eso lo hacer por cada objeto, puede verse en un problema de velocidad en su respuesta. <br/>
				Para esto puede especificar un serializador dentro de su modelo declarando un metodo llamado <span class="label">collectionSerializer</span>, si el <span class="label">OData</span> detecta que este metodo existe en su modelo lo usará para serializar la colección antes de pasarselo al transformador. puede usar esta ventaja para realizar allí las consultas que necesita a su base de datos e ir armando la colección y una vez armada simplemente se la pasamos a los transformadores.<br/>
				de está manera los transformadores ya no se verán obligados a realizar consultas por cada objeto si no simplemente a pintar las propiedades que ya vienen en la colección. un ejemplo de esto podría ser llamar un procedimiento almacenado o una consulta multitabla que devuelva todos los campos de las tablas que se necesitan en la consulta e ir armando la coleción con base en estos valores ejemplo:

				<div class="code-block">
					<span class="comment-code">// ...</span><br/>
					<span class="purple-code">class</span> <span class="yellow-code">User</span> <span class="purple-code">extends</span> <span class="green-code">Model</span><br/>
					{
						<div class="code-padding">
							<span class="comment-code">// ...</span><br/>
							<span class="purple-code">public function</span> <span class="yellow-code">collectionSerializer</span><span class="code-sign">( <span class="blue-code">$collection</span> )</span><br/>
							{
								<div class="code-padding">
									<span class="comment-code">/* llamamos una consulta multitabla compleja que nos devuelva en una sola transacción un calculo procesado.
									 en este caso pedimos la cantidad de suscripciones que ha comprado el usuario en el ultimo año.
									 bueno puede que en realidad esta consulta no sea tan compleja entonces piensa en una consulta mas complicada :v <br/>
									 el punto es que aquí en el serializador se hace una sola consulta a la base de datos que ya nos trae todos los datos que necesitamos 
									 entonces simplemente le asignamos esos valores a la coleción que nos pasa el OData y ya cuando pase por el transformador no se harán mas consultas a la DB.
									  */<br/>
									</span><br/>
									<span class="blue-code">$query </span> = 
									<span class="yellow-code">collect</span><span class="code-sign"></span><span class="code-sign">(</span> \<span class="blue-code">DB</span><span class="code-sign">::<span class="yellow-code">select</span>(
										<span class="green-code">"select users.id as 'user_id', subscriptions.* , user_subscriptions.quantity_subscriptions from users, subscriptions, user_subscriptions where ..."</span>
									) )</span>;
									<br/>
									<span class="blue-code">$users</span> = <span class="blue-code">$collection</span>-><span class="blue-code">map</span><span class="code-sign">(
										<span class="purple-code">function</span> ( <span class="blue-code">$user</span> ) <span class="purple-code">use</span> ( <span class="blue-code">$query</span> ) {
										<div class="code-padding">
											<span class="comment-code">
												/*la consulta nos devuelve una propiedad con el nombre quantity_subscriptions, cada modelo de usuarios no trae esta propiedad entonces
												iteramos la colección y  vamos asignando esta propiedad a cada uno de los usuarios de la colección que nos paso el OData por parámetro en el metodo.
												usando los resultados de la consulta compleja que acabamos de hacer.<br/>
												de esta manera los transformadores ya no tendrán que hacer consultas a la base de datos para obtener esta propiedad por que ya viene en la coleción.
												*/
											</span><br/>
											<span class="blue-code">$user</span><span class="light-code">->quantity_subscriptions =</span> <span class="blue-code">$query</span>-><span class="yellow-code">where</span><span class="code-sign">( <span class="green-code">"user_id"</span> , <span class="blue-code">$user</span><span class="light-code">->id</span> )</span><span class="light-code">->quantity_subscriptions;</span>
											<br/>
											<span class="purple-code">return</span> <span class="blue-code">$user</span>;
										</div>
									} )</span>;<br/>
									<span class="purple-code">return</span> <span class="blue-code">$users</span>;
								</div>
							}<br/>
							<span class="comment-code">// ...</span>
						</div>
					}
				</div>

				<h3># Usando clases</h3>

				Si no desea asignar la logica del serializador a su modelo, puede igualmente usar una clase para personalizar este trabajo, solo tiene que crear una clase común que tenga igualmente un metodo llamado <span class="label">collectionSerializer</span>. esto le sirve para trabajar con multiples metodos dentro de su clase y separar la logica de serialización de datos de su modelo. 

				<div class="code-block">
					<span class="purple-code">namespace</span> App\Serializers; <br/><br/>
					<span class="purple-code">class</span> <span class="yellow-code">UserSerializer</span><br/>
					{
						<div class="code-padding">
							<span class="comment-code">// ...</span><br/>
							<span class="purple-code">public function</span> <span class="yellow-code">collectionSerializer</span><span class="code-sign">( <span class="blue-code">$collection</span> )</span><br/>
							{
								<div class="code-padding">
									<span class="blue-code">$query </span> = 
									<span class="yellow-code">collect</span><span class="code-sign"></span><span class="code-sign">(</span> \<span class="blue-code">DB</span><span class="code-sign">::<span class="yellow-code">select</span>(
										<span class="green-code">"select users.id as 'user_id', subscriptions.* , user_subscriptions.quantity_subscriptions from users, subscriptions, user_subscriptions where ..."</span>
									) )</span>;
									<br/>
									<span class="blue-code">$users</span> = <span class="blue-code">$collection</span>-><span class="blue-code">map</span><span class="code-sign">(
										<span class="purple-code">function</span> ( <span class="blue-code">$user</span> ) <span class="purple-code">use</span> ( <span class="blue-code">$query</span> ) {
										<div class="code-padding">
											<span class="blue-code">$user</span><span class="light-code">->quantity_subscriptions =</span> <span class="blue-code">$query</span>-><span class="yellow-code">where</span><span class="code-sign">( <span class="green-code">"user_id"</span> , <span class="blue-code">$user</span><span class="light-code">->id</span> )</span><span class="light-code">->quantity_subscriptions;</span>
											<br/>
											<span class="purple-code">return</span> <span class="blue-code">$user</span>;
										</div>
									} )</span>;<br/>
									<span class="purple-code">return</span> <span class="blue-code">$users</span>;
								</div>
							}<br/>
							<span class="comment-code">// ...</span>
						</div>
					}
				</div>

				Una vez construida su clase deberá asignar la propiedad <span class="label">serializer</span> a su modelo especificando la clase que debe usar para serializar las colecciones de datos. si especifico esta propiedad en su modelo el <span class="label">OData</span> la usará para serializar los datos de su colección.

				<div class="code-block">
					<span class="comment-code">// ...</span><br/>
					<span class="purple-code">class</span> <span class="yellow-code">User</span> <span class="purple-code">extends</span> <span class="green-code">Model</span>
					{
						<div class="code-padding">
							<span class="comment-code">// ...</span><br/>
							<span class="purple-code">public</span> <span class="blue-code">$serializer</span> <span class="code-sign">=</span> <span class="green-code">"App\Serializers\UserSerializer"</span>;<br/>
							<span class="comment-code">// ...</span>
						</div>
					} <br/>
					<span class="comment-code">// ...</span>
				</div>

			</article>

			<article>
				<h1> <span class="item-icon">#</span> Paginación</h1>

				Uno de los factores mas influyentes en la velocidad de respuesta de su <span class="label">API</span> está en la paginación, toda aplicación está propensa a crecer desmesuradamente, puede que al inicio tenga que trabajar por ejemplo con un modelo de ordenes, y este tenga en la base de datos almacenedas 50 ordenes. lo cual traer 50 ordenes en una petición no supone ningún problema y no debería tener ningún retrazo en la velocidad de respuesta. <br/>
				Sin embargo a medida que crece su aplicación y los usuarios empiezan a registrar ordenes puede encontrarse con el caso de tener 50.000 ordenes registradas en su base de datos, traerse estas 50.000 ordenes en una sola petición no solo supone un retrazo en la respuesta de la <span class="label">API</span> si no que renderizar 50.000 datos en una tabla desde el <span class="label">FrontEnd</span> puede también causar un problema en la Memoria de la computadorá del usuario. <br/>
				Para evitar este tipo de problemas lo que mas se recomienda es usar paginación desde el inicio y por supuesto que puede hacerlo usando el <span class="label">OData</span>. para implementar la paginación usando el <span class="label">OData</span> deberá pasar los parámetros <span class="label">top</span> y <span class="label">page</span> a la url de la ruta donde expuso su modelo usando el metodo <span class="label">odataJsonResponse</span>.

				<div class="cmd-code">https://myapi.com/api/users?top=20&page=1</div>

				El parámetro <span class="label">top</span> indica el número maximo de registros por petición que debe devolver la <span class="label">API</span> en este caso 20 y el parámetro <span class="label">page</span> indica la página que debe traer en este caso la primera. por lo que la anterior consulta deberá traer los usuarios del 1 al 20, el siguiente ejemplo consulta los usuarios del 21 al 40:

				<div class="cmd-code">https://myapi.com/api/users?top=20&page=2</div>

				La siguiente el 41 al 60:

				<div class="cmd-code">https://myapi.com/api/users?top=20&page=3</div>

				y así sucesivamente ...
			</article>

			<article>
				<h1> <span class="item-icon">#</span> Filtros</h1>

				Como se menciono al inicio, las rutas de su <span class="label">API</span> no solamente devuelven los datos de una base de datos si no que también deben filtrar estos datos según la necesidad de la logica de negocio. por ejemplo si está exponiendo un modelo de usuarios puede que necesite filtrarlos ya sea por ciudad, por rol, por estado o por muchas mas opciones, esto lo puede llevar a tener un monton de rutas con filtros especificos solo para los usuarios lo cual extiende mucho mas los tiempos de desarrollo. <br/> 

				Con el <span class="label">OData</span> puede mantener una sola ruta para su modelo y empezar a agregar filtros desde la url, esto le permite olvidarse de tener que programar cada filtro que necesite en su <span class="label">API</span> a demas de que le da la posibilidad a los desarroladores <span class="label">Frontend</span> jugar un poco mas con las rutas de su <span class="label">API</span> y no depender de usted como desarrolador <span class="label">Backend</span> cada vez que necesiten un filtro especifico. <br/>

				Para empezar a aplicar filtros no olvide que debe crear un ruta que apunte a un metodo en su controlador y este metodo debe exponer el <span class="label">odataJsonResponse</span>. una vez tenga esto ya estará listo para empezar agregar filtros desde su api. <br/>

				Por ultimo debe saber que el <span class="label">OData</span> filtrará los datos con base en los campos de la tabla en su base de datos mas no en los campos que declaro en su transformador, esto se mantiene así para poder escalar usando consultar mas complejas que incluyen <span class="label">inner joins</span> entonces es una muy buena idea que el nombre de los campos en su transformador sean fieles a los nombre de los campos que tiene en la base de datos, ya que podría confundir a los desarroladores que consumen su <span class="label">API</span>. <br/>

				Para ayudarlo a comprender mejor los siguientes casos de uso tome como ejemplo un modelo de usuarios que se expone usando el metodo <span class="label">odataJsonResponse</span> a travez de la ruta <span class="label">https://myapi.com/api/users</span> y que devuelve una respuesta como esta:

				<div class="code-block">
					{
						<div class="code-padding">
							<span class="green-code">"data"</span> : [
							<div class="code-padding">
								<span class="green-code">"data"</span> : [
									<div class="code-padding">
										{
											<div class="code-padding">
												<span class="green-code">"id"</span> : <span class="code-sign">1</span>,<br/>
												<span class="green-code">"name"</span> : <span class="green-code">"example user"</span>,<br/>
												<span class="green-code">"role_id"</span> : <span class="code-sign"> 2 </span> ,<br/>
												<span class="green-code">"state_id"</span> : <span class="code-sign"> 1 </span> ,<br/>
												<span class="green-code">"city_id"</span> : <span class="code-sign"> 12 </span> ,<br/>
												<span class="comment-code">// ...rest</span>
											</div>
										}, <br/>
										{
											<div class="code-padding">
												<span class="green-code">"id"</span> : <span class="code-sign">2</span>,<br/>
												<span class="comment-code">// ...rest</span>
											</div>
										}
									</div>
								], <br/>
								<span class="green-code">"length"</span> : <span class="code-sign">2</span> <span class="comment-code">// número de registro en la colección</span>
							</div>
							],<br/>
							<span class="green-code">"code"</span> : <span class="yellow-code">200</span>
						</div>
					}
					</span>
				</div>

				<h3> # Condicional igual que </h3>

				Para filtrar datos de que cumplan con una condicional exacta puede espeficiar el nombre del atributo segudo de <span class="label">:</span> y seguido del valor con el que debe cumplir. un ejemplo de un filtro que trae los usuarios que vivien en la ciuedad con id <span class="label">2</span>.

				<div class="cmd-code">https://myapi.com/api/users?filter=city_id:2</div> 

				Esto lo puede aplicar con cualquier atributo de su tabla, pero tenga en cuenta de que si usa el operador <span class="label">:</span> se filtrarán solo los datos que cumplan con la condición exacta por lo que si desea filtrar usando por ejemplo el nombre deberá pasar el nombre exacto incluyendo mayuscula y minusculas ejemplo:

				<div class="cmd-code">https://myapi.com/api/users?filter=name:Pepito Peréz</div>

				<h3> # Condicional diferente de </h3>

				Si desea aplicar la invarsa de igual que para en lugar de obtener los datos que cumplan con una condición en especifico, mas bien anular los registros que no cumplan con una condición especifica puede usar el operador <span class="label">!</span> que en este caso funciona igual que el operador <span class="label">!=</span> que se usa por ejemplo en el <span class="label">if</span>. un ejemplo de una consulta de usuario donde el id sea diferente a <span class="label">13</span>, esto nos traera todos los usuarios menos el del id 13:

				<div class="cmd-code">https://myapi.com/api/users?filter=id!13</div>

				<h3># Condicional like</h3>

				Con la condicional igual que podemos filtrar datos que cumplen una condición exacta pero si lo que desea es filtrar por coincidencia en lugar de usar el operador <span class="label">:</span> puede usar el operador <span class="label">/</span> esto lo que hará es filtrar los usuarios por coincidencia por ejemplo en el caso de <span class="label">Pepito Peréz</span> podemos filtrarlo pasando nomas <span class="label">pepito</span> y en minuscula obviamente esto nos traerá otros usuarios que tengan igualmente en su nombre pepito ejemplo:

				<div class="cmd-code">https://myapi.com/api/users?filter=name/pepito</div>

				<h3># Condicional mayor que</h3>

				Puede filtrar datos númeroricos que sean mayores a un valor especifico usando el operador <span class="label">></span> por ejemplo esta sería una consulta que trae todos los usuarios con el id mayor a 10:

				<div class="cmd-code">https://myapi.com/api/users?filter=id>10</div>

				también puede aplicar este filtro usando fechas:

				<div class="cmd-code">https://myapi.com/api/users?filter=created_at>2023-04-25</div>

				<h3># Condicional menor que </h3>

				al igual que el operador <span class="label">></span> puede usar el operador <span class="label"><</span> . funciona igual solo que en lugar de filtrar datos mayores a cierto valor filtrará los datos que sean menores a lo especificado:

				<div class="cmd-code">https://myapi.com/api/users?filter=id<10</div>

				igualmente puede aplicar fechas de esta manera:

				<div class="cmd-code">https://myapi.com/api/users?filter=created_at<2023-04-25</div>

				<h3># Condicional in</h3>

				Puede filtrar datos que se encuentren en un rango de valores especificos usando la condificional <span class="label">in</span> , un ejemplo podría ser una consulta de los usuarios que tengan en su id un número del uno al 10 ejemplo:

				<div class="cmd-code">https://myapi.com/api/users?filter=id[1-2-3-4-5-6-7-8-9-10]</div>

				en este caso se usa el separador <span class="label">-</span> para separar los valores que se tendrán en cuenta al filtrar los datos. no se usa <span class="label">,</span> ya que la coma tiene otra funcionalidad reservada. igualmente puede filtrar no solamente usando números si no también letras ejemplo:

				<div class="cmd-code">https://myapi.com/api/users?filter=name[Pepito Peréz-Pepito Lopéz]</div>

				<h3># Usando and</h3>

				Si bien puede filtrar los datos de su <span class="label">API</span> usando diferentes tipos de operadores es logico pensar que necesite aplicar mas de un filtro a la vez, un ejemplo podría ser una consulta de los usuarios que viven en la ciudad con id 5 y que tengan el rol con id 3. para aplicar una consulta como esta solo tiene que separar los filtros que ya aprendio anteriormente por una <span class="label">,</span> entonces el filtro nos quedaría de esta manera:

				<div class="cmd-code">https://myapi.com/api/users?filter=city_id:5,role_id:3</div>

				pueda agregar tantos filtros al tiempo como guste solo debe separarlos por <span class="label">,</span> y el <span class="label">OData</span> filtrará los datos que cumplan todas las condicionales que se le pasarón por url, un ejemplo mas:

				<div class="cmd-code">https://myapi.com/api/users?filter=id[1-2-3],created_at>2023-04-25,role_id!2</div>

				<h3># Usando or</h3>

				al igual que con <span class="label">and</span> puede aplicar multiples filtros a la vez pero en lugar de separlos usando <span class="label">,</span> tendrá que separarlos usando <span class="label">|</span> . en este caso el <span class="label">OData</span> no filtrará los usuarios que cumplan con todos los filtros pasados a la url si no que filtrará los usuarios que cumplan con alguno de ellos, no es necesario que cumpla con todas las reglas le bastará solo con cumplir una. un ejemplo podría ser una consulta a los usuarios que viven en la ciudad con id 1 o con id 2:

				<div class="cmd-code">https://myapi.com/api/users?filter=city_id:1|city_id:2</div>

				igualmente puede agregar tantos filtros como desee en la url simplemente debe separarlos por <span class="label">|</span> , un ejemplo mas:

				<div class="cmd-code">https://myapi.com/api/users?filter=role_id:1|role_id:2|city_id:5|city_id:7|id[1-2-3-4-5]</div>

			</article>

			<article>
				<h1> <span class="item-icon">#</span> Separando filtros</h1>

				Si bien puede separar sus filtros usando <span class="label">and</span> u <span class="label">or</span> debe saber que no debe mezclar estás 2 condicionales en una sola consulta por ejemplo la siguiente consulta no funcionará:

				<div class="cmd-code">https://myapi.com/api/users?filter=id:1|id:2,role_id:3</div>

				En este caso se están aplicando tanto el separador <span class="label">,</span> como el <span class="label">|</span> lo cual generará conflictos en la consulta a la base de datos, esto no es un problema del <span class="label">OData</span> si no mas bien un problema de separación de condicionales en <span class="label">SQL</span>. si realiza este tipo de consulta no obtendrá ningún tipo de error pero puede que el filtro simplemente falle y no traiga los datos que usted solicito. <br/> <br/>

				<h3># Usando select</h3>

				puede separar sus filtros usando el parámetro <span class="label">select</span> que actua como un filtrado del resultado de <span class="label">filter</span> por lo que primero se filtrarán los datos usando las condicionales pasadas a <span class="label">filter</span> y encima de ese resultado se aplica los filtros enviados por <span class="label">select</span> esto en <span class="label">SQL</span> es equivalente a hacer un <span class="label">select * from (select ...)</span> es decir una consulta sobre otra consulta. <br/>
				<span class="label">select</span> funciona exactamente igual que filter usa los mismos operadores y los mismos separadores <span class="label">and</span> y <span class="label">or</span> ejemplo:

				<div class="cmd-code">https://myapi.com/api/users?select=id[1-2-3],role_id:5</div>
				<div class="cmd-code">https://myapi.com/api/users?select=city_id:7|id<10</div>

				puede usar esta ventaja para poner sus filtros tipo <span class="label">and</span> por ejemplo en el parámetro <span class="label">filter</span> y los filtros tipo <span class="label">or</span> en el parámetro <span class="label">select</span> ejemplo:

				<div class="cmd-code">https://myapi.com/api/users?filter=role_id:3,state_id:1&select=id:1|id:2</div>

				o puede hacerlo al reves para que <span class="label">filter</span> maneje los filtros topo <span class="label">or</span> y <span class="label">select</span> los filtros tipo <span class="label">and</span> ejemplo:

				<div class="cmd-code">https://myapi.com/api/users?filter=id:1|id:2&select=role_id:3,state_id:1</div>

				el punto es que de está manera separamos las condicionales, evitamos conflictos de parentesis en las consultas de la base de datos y nos aseguramos de que el filtro funcione correctamente y devuelva los datos según lo que se necesita. <br/>

				si bien <span class="label">select</span> es un sobre filtro del resultado que arroja <span class="label">filter</span> debe tener en cuenta que <span class="label">filter</span> es mas poderoso que <span class="label">select</span> y que con <span class="label">filter</span> podemos hacer consultas incluyendo <span class="label">inner joins</span> lo cual no se puede hacer con <span class="label">select</span>. tenga esto en cuenta al momento de decidir a quien asignarle la responsabilidad del filtro por tipo <span class="label">or</span> o <span class="label">and</span>.
			</article>

			<article>
				<h1> <span class="item-icon">#</span> Consultas anidadas</h1>

				Uno de los casos mas comunes a la hora filtrar datos en una base de datos es hacer consultas multitabla o <span class="label">Inner joins</span> para poder filtrar por ejemplo usuarios con base en datos almacenados en otras tablas, un ejemplo podría ser una tabla de peliculas que tiene las siguientes relaciones en la base de datos:

				<div class="code-block">
					<table class="inline-block">
						<thead>
							<th>movies</th>
						</thead>
						<tbody>
							<tr>
								<td>id</td>
							</tr>
							<tr>
								<td>name</td>
							</tr>
							<tr>
								<td>description</td>
							</tr>
							<tr>
								<td>category_id</td>
							</tr>
						</tbody>
					</table>

					<table class="inline-block">
						<thead>
							<th>categories</th>
						</thead>
						<tbody>
							<tr>
								<td>id</td>
							</tr>
							<tr>
								<td>name</td>
							</tr>
							<tr>
								<td>state_id</td>
							</tr>
						</tbody>
					</table>

					<table class="inline-block">
						<thead>
							<th>states</th>
						</thead>
						<tbody>
							<tr>
								<td>id</td>
							</tr>
							<tr>
								<td>name</td>
							</tr>
						</tbody>
					</table>

				</div>

				<h3># Inner Joins </h3>

				En este caso la tabla movies se relaciona con categories atravéz de la foranea <span class="label">category_id</span> y categories se relaciona con states atravéz de la foranea <span class="label">state_id</span>. aunque en el <span class="label">OData</span> oficialmente los inner joins no están disponibles es posible solictar inner joins en este paquete usando un filtro desde la url. <br/>
				En el caso de que quiera filtrar las peliculas por categoría puede hacerlo normalmente usando la foranea <span class="label">category_id</span> aplicandola en un filtro normal ejemplo:

				<div class="cmd-code">
					https://myapi.com/api/movies?filter=category_id:1
				</div>

				Sin embargo en el caso de que quiera filtrar las peliculas por el nombre de la categoría tendrá que aplicar un inner join para poder acceder al nombre de la categoría. en este caso el filtro se aplica igual con la diferencia de que debe especificar el nombre de las tablas concatenadas por un punto ejemplo:

				<div class="cmd-code">
					https://myapi.com/api/movies?filter=categories.name:Infantil
				</div>

				Es mas común que intente filtrar por nombre usando coincidencia mas no equivalencia entonces el filtro mas cumún podría verse así para el caso de un buscador:

				<div class="cmd-code">
					https://myapi.com/api/movies?filter=categories.name/Infan
				</div>

				Puede anidar tantas tablas como necesite solo debe separarlas pur un punto, una consulta mas anida por ejemplo podía ser filtrar las peliculas cuya categoría tenga el estado con nombre <span class="label">habilitado</span> en este caso la url nos quedaría así:

				<div class="cmd-code">
					https://myapi.com/api/movies?filter=categories.states.name:habilitado
				</div>

				<h3>Usando alias</h3>

				Si bien el <span class="label">OData</span> en este caso nos permite hacer consultas mas complejas utilizando inner joins es verdad que el hecho de tener que pasar el nombre de la tabla por url puede ser confuso para los desarroladores <span class="label">Frontend</span> ya que lo mas probable es que ellos no conozcan el nombre de las tablas de su base de datos y por ende no sepan como realizar el filtro. <br/>
				para solucionar este problema usted puede agregarle alias a sus tablas para que el <span class="label">OData</span> identifique la tabla a la que se hace referencia incluso si se pasa un nombre completamente distinto desde la url, sin embrago debe tener en cuenta que de igual manera los desarroladores <span class="label">Frontend</span> deben tener una referencia de las relaciones en la respuesta de su <span class="label">API</span>, por ejemplo continuando con el ejemplo anterior usted podría devolver por cada objeto de su transformador algo como esto:

				<div class="code-block">
					[
						<div class="code-padding">
							{
								<div class="code-padding">
									<span class="green-code">"id"</span> : <span class="code-sign">1</span>,<br/>
									<span class="green-code">"name"</span> : <span class="green-code">"movie 1"</span>,<br/>
									<span class="green-code">"description"</span> : <span class="green-code">"descripction of movie"</span>,<br/>
									<span class="green-code">"category_id"</span> : <span class="code-sign">1</span>,<br/>
									<span class="green-code">"category"</span> : {
										<div class="code-padding">
											<span class="green-code">"id"</span> : <span class="code-sign">1</span>, <br/>
											<span class="green-code">"name"</span> : <span class="green-code">"acción"</span>, <br/>
											<span class="green-code">"state_id"</span> : <span class="code-sign">1</span>, <br/>
											<span class="green-code">"state"</span> : {
												<div class="code-padding">
													<span class="green-code">"id"</span> : <span class="code-sign">1</span> <br/>
													<span class="green-code">"name"</span> : <span class="green-code">"habilitado"</span> <br/>
												</div>
											}
										</div>
									}
								</div>
							}, <br/>
							{
								<div class="code-padding">
									<span class="comment-code">// rest data ...</span>
								</div>
							}
						</div>
					]
				</div>

				En este caso lo mas probable es que el desarrolador <span class="label">Frontend</span> intente filtrar según lo que el ve en la respuesta de la <span class="label">API</span>. entonces si quiere filtrar por el nombre del estado de la categoría lo que tendría mas sentido es que la url quedará de esta manera:

				<div class="cmd-code">
					https://myapi.com/api/movies?filter=category.state.name:habilitado
				</div>

				Si se da cuenta es lo mismo que nombrar las tablas aniadadas como lo hicimos anteriormente <span class="label">filter=categories.states.name:habilitado</span> sin embargo para que esto funcione en singular como está en la respuesta de su <span class="label">API</span> deberá agregar alias a sus tablas. para hacer esto cree un <span class="label">config/odata.php</span> en su proyecto que devulva un array con la configuración que requiere el <span class="label">OData</span> para usar los alias, no olvide que la carpeta <span class="label">config</span> ya viene por defecto creada en su proyecto junto con otros archivos de configuración como <span class="label">app.php</span> , <span class="label"> auth.php</span> etc ... <br/> en este caso solo tendrá que crear un archivo llamado <span class="label">odata.php</span> junto con la siguiente configuración de ejemplo:

				<div class="code-block">
					<xmp> <?php </xmp>
					<div class="code-divider"></div>
					<span class="purple-code">return</span> [
						<div class="code-padding">
							<span class="green-code">"singular"</span> <span class="yellow-code">=></span> [
								<div class="code-padding">
									<span class="green-code">"category"</span> <span class="yellow-code">=></span> <span class="green-code">"categories"</span> , <br/>
									<span class="green-code">"state"</span> <span class="yellow-code">=></span> <span class="green-code">"states"</span> , <br/>
									<span class="comment-code">"alias de la tabla" => "nombre de la tabla"</span>
								</div>
							]
						</div>
					];
				</div>

				y listo esto es todo lo que tiene que hace para agregar alias a sus tablas, por ultimo no olvide que puede igualmente usar todos los operadores y las condicionales <span class="label">and</span> y <span class="label">or</span> que usa en sus filtros normales en los inner joins un ejemplo:

				<div class="cmd-code">
					https://myapi.com/api/movies?filter=category.state.name:habilitado|category.state.name:activado|category.name:acción
				</div>
			</article>

			<article>
				<h1> <span class="item-icon"># </span> Manejando datos </h1>
				Aparte de poder filtrar los datos de su <span class="label">API</span> atravéz de la url también puede realizar otro tipo de operaciones adicionales sobre sus datos para mantener de mejor manera los resultados de las consultas a su <span class="label">API</span>. <br/> <br/>

				<h3> # orderBy </h3>

				Puede solicitarle a la <span class="label">API</span> que ordene los resultados con base en uno de los campos del modelo, para esto puede pasarle el parámetro <span class="label">orderBy</span> en la url y este parámetro debe indicar el campo por el que se desea ordenar los resultados ejemplo:

				<div class="cmd-code">https://myapi.com/users?orderBy=id</div>

				En el caso de tratarse de un entero se ordenarán los datos de menor a mayor, en el caso de un string se ordenarán alfabeticamente de la <span class="label">A-Z</span> y en el caso de las fechas se ordenarán los registros del mas viejo al mas nuevo ejemplo:

				<div class="cmd-code">https://myapi.com/users?orderBy=id <span class="comment-code">// ordenados de menor a mayor</span></div>
				<div class="cmd-code">https://myapi.com/users?orderBy=name <span class="comment-code">// ordenados de la A-Z</span></div>
				<div class="cmd-code">https://myapi.com/users?orderBy=created_at <span class="comment-code">// ordenados del mas viejo al mas nuevo</span></div>

				<h3># orderByDesc</h3>

				Al igual que el parámetro <span class="label">orderBy</span> puede usar el parámetro <span class="label">orderByDesc</span> para ordenar los resultados de la <span class="label">API</span> este parámetro funciona igual que <span class="label">orderBy</span> con la diferencia de que ordenará los datos a la inverza ejemplo:

				<div class="cmd-code">https://myapi.com/users?orderByDesc=id <span class="comment-code">// ordenados de mayor a menor</span></div>
				<div class="cmd-code">https://myapi.com/users?orderByDesc=name <span class="comment-code">// ordenados de la Z-A</span></div>
				<div class="cmd-code">https://myapi.com/users?orderByDesc=created_at <span class="comment-code">// ordenados del mas nuevo al mas viejo</span></div>

				<h3># first</h3>

				Por defecto las repuesta de la <span class="label">API</span> devolverán una colección de datos. en algunos casos puede que necesite traerse la información de un solo modelo lo cual no es viable obtener la coleción de datos y luego llamar el registro de la posisión cero por ejemplo <span class="label">users[0]</span>. para solucionar esto usted puede pensar en crearse un endpoint que por url le pase el id del modelo que quiere obtener y devolver la información de este registro en un objeto en lugar de una coleción de datos por ejemplo:

				<div class="cmd-code">https://myapi.com/users/1</div>

				Sin embargo esto ya es posbile hacerlo usando el <span class="label">OData</span> no tendrá que agregar un nuevo endpoint solo deberá pasar el parámetro <span class="label">first</span> a la url que ya devuelve la coleción de datos y este en lugar de devolver una coleción como esta por ejemplo:

				<div class="code-block">
					{
						<div class="code-padding">
							<span class="green-code">"data"</span> : {
								<div class="code-padding">
									<span class="green-code">"data"</span>: [
									<div class="code-padding">
										{
											<div class="code-padding">
												<span class="green-code">"id"</span> : <span class="code-sign">1</span>, <br/>
												<span class="comment-code">// ...rest of your object</span>
											</div>
										}, <br/>
										{
											<div class="code-padding">
												<span class="green-code">"id"</span> : <span class="code-sign">2</span>, <br/>
												<span class="comment-code">// ...rest of your object</span>
											</div>
										},<br/>
										<span class="comment-code">// ... rest</span>
									</div>
									], <br/>
									<span class="green-code">"length"</span>: <span class="code-sign">20</span>
								</div>
							}, <br/>
							<span class="green-code">"code"</span> : <span class="yellow-code">200</span>
						</div>
					}
				</div>

				Le devolverá un solo objeto en este caso el primero de la coleción:

				<div class="code-block">
					{
						<div class="code-padding">
							<span class="green-code">"data"</span> : {
								<div class="code-padding">
									<span class="green-code">"data"</span>: {
									<div class="code-padding">
										<span class="green-code">"id"</span> : <span class="code-sign">1</span>, <br/>
										<span class="comment-code">// ...rest of your object</span>
									</div> } <br/>
									<span class="green-code">"length"</span>: <span class="code-sign">1</span>
								</div>
							}, <br/>
							<span class="green-code">"code"</span> : <span class="yellow-code">200</span>
						</div>
					}
				</div>

				Si desea obtener un objeto diferente al primero simplemente aplique un filtro por id para obtener unicamente el dato por este id y aplique igualmente el parámetro <span class="label">first</span> para que traiga ese dato en un objeto en lugar de una coleción ejemplo:

				<div class="cmd-code">https://myapi.com/users?filter=id:5&first</div>

				Esta sería la respuesta que recibiriamos:

				<div class="code-block">
					{
						<div class="code-padding">
							<span class="green-code">"data"</span> : {
								<div class="code-padding">
									<span class="green-code">"data"</span>: {
									<div class="code-padding">
										<span class="green-code">"id"</span> : <span class="code-sign">5</span>, <br/>
										<span class="comment-code">// ...rest of your object</span>
									</div> } <br/>
									<span class="green-code">"length"</span>: <span class="code-sign">1</span>
								</div>
							}, <br/>
							<span class="green-code">"code"</span> : <span class="yellow-code">200</span>
						</div>
					}
				</div>

				<h3> # Auth User </h3>

				Si bien ya puede filtrar los datos de la <span class="label">API</span> usando cualquiera de los campos de su modelo puede que necesite filtrar los datos por el <span class="label">Bearer token</span> es decir por el usuario actualmente loguado. aunque puede pasar el id del usuario por parámetro normalmente por ejemplo si quiere filtrar las ordenes del usuario podría usar un filtro de este tipo:

				<div class="cmd-code">https://myapi.com/orders?filter=user_id:1</div>

				Sin embargo el tener que pasar el id del usuario por la url obliga al desarrollador <span class="label">Frontend</span> a realizar un proceso extra para obtener el id del usuario logueado y luego pasarlo por parámetro. con el <span class="label">OData</span> usted puede evitar este proceso extra indicando el alias <span class="label">{auth.user.id}</span> en su url, de esta manera el <span class="label">OData</span> usará el id del usuario logueado obtenido de la función <span class="label">auth()->user()</span> de laravel ejemplo:

				<div class="cmd-code">https://myapi.com/orders?filter=user_id:{auth.user.id}</div>

				No solamente puede usar el id del usuario, puede usar las demas propiedades también ya que <span class="label">{auth.user}</span> es una alias para el objeto del usuario actual. entonces por ejemplo podemos usar un filtro también por el nombre de usuario de esta manera:

				<div class="cmd-code">https://myapi.com/orders?filter=user.name:{auth.user.name}</div>


			</article>

			<article>
				<h1> <span class="item-icon">#</span> Exportando datos</h1>

				Una de las funcionalidades mas comunes en una <span class="label">API</span> es la exportación de datos ya sea en <span class="label">CSV</span> , <span class="label">Excel</span> o cualquier otro medio donde se puedan descargar. <a href="https://laravel-excel.com/" class="article-link" target="_blank">maatwebsite/excel</a> ofrece una librería muy completa para manejar la exportación de datos en laravel, este paquete de <span class="label">OData</span> es completamente compatible con laravel-excel. puede usar esta ventaja para exportar colecciones en <span class="label">CSV</span> por ejemplo pero manteniendo el uso del <span class="label">OData</span> para poder filtrar y ordenar los datos en su archivo de <span class="label">EXCEL</span>. <br/><br/>

				<h3># Usando laravel excel</h3>
				Para empezar instale el paquete de <a href="https://laravel-excel.com/" class="article-link" target="_blank">maatwebsite/excel</a> en su proyecto y luego cree una clase de tipo export para su modelo de esta manera: <br/>

				<div class="cmd-code">
					php artisan make:export UserExport
				</div>

				Esto debio crearle un <span class="label">app/Exports/UserExport.php</span> archivo en su proyecto. lo siguiente que debe hacer es agregar un constructor dentro de la clase que resiva la coleción que le pasará a el <span class="label">OData</span> y usar esta coleción para armar las propiedades de su archivo. la coleción que pasa el <span class="label">OData</span> al constructor es la coleción procesada con los filtros, paginación y demas instrucciones que hayan pasado a la url.

				<div class="code-block">
					<xmp><?php</xmp>
					<div class="code-divider"></div>
					<span class="purple-code">namespace</span> App\Exports;
					<br/><br/>
					<span class="purple-code"> use </span>App\Models\<span class="yellow-code">User</span>;<br/>
					<span class="purple-code"> use </span>Illuminate\Support\<span class="yellow-code">Collection</span>;<br/>
					<span class="purple-code"> use </span>Illuminate\Support\Facades\<span class="yellow-code">DB</span>;<br/>
					<span class="purple-code"> use </span>Maatwebsite\Excel\Concerns\<span class="yellow-code">WithTitle</span>;<br/>
					<span class="purple-code"> use </span>Maatwebsite\Excel\Concerns\<span class="yellow-code">Exportable</span>;<br/>
					<span class="purple-code"> use </span>Maatwebsite\Excel\Concerns\<span class="yellow-code">WithMapping</span>;<br/>
					<span class="purple-code"> use </span>Maatwebsite\Excel\Concerns\<span class="yellow-code">WithHeadings</span>;<br/>
					<span class="purple-code"> use </span>Maatwebsite\Excel\Concerns\<span class="yellow-code">ShouldAutoSize</span>;<br/>
					<span class="purple-code"> use </span>Maatwebsite\Excel\Concerns\<span class="yellow-code">FromCollection</span>;<br/>
					<br/>
					<span class="purple-code">class</span> <span class="yellow-code">UserExport</span> <span class="purple-code">implements</span>
					<span class="code-sign"> FromCollection</span>, 
					<span class="code-sign"> ShouldAutoSize</span>, 
					<span class="code-sign"> WithTitle</span>, 
					<span class="code-sign"> WithMapping</span>, 
					<span class="code-sign"> WithHeadings</span> <br/>
					{
						<div class="code-padding">
							<span class="purple-code">use</span> <span class="code-sign">Exportable</span>; <br/><br/>
							<span class="purple-code">private</span> collection; <br/> <br/>
							
							<span class="purple-code">public function</span> <span class="green-code">__construct</span><span class="code-sign">( <span class="yellow-code">Collection</span> <span class="blue-code">$collection</span> )</span>
							{
								<div class="code-padding">
									<span class="blue-code">$this</span><span class="code-sign">-></span>collection <span class="yellow-code">=</span> <span class="blue-code">$collection</span>;
								</div>
							} <br/> <br/>

							<span class="purple-code">public function</span> <span class="yellow-code">collection</span><span class="code-sign">( )</span>
							{
								<div class="code-padding">
									<span class="purple-code">return</span> <span class="blue-code">$this</span><span class="code-sign">-></span>collection;
								</div>
							} <br/> <br/>

							<span class="purple-code">public function</span> <span class="yellow-code">title</span><span class="code-sign">( )</span> : <span class="code-sign">string</span>
							{
								<div class="code-padding">
									<span class="purple-code">return</span> <span class="green-code">"Usuarios"</span>;
								</div>
							} <br/> <br/>

							<span class="purple-code">public function</span> <span class="yellow-code">map</span><span class="code-sign">( <span class="blue-code">$user</span> )</span> : <span class="code-sign">array</span>
							{
								<div class="code-padding">
									<span class="purple-code">return</span> [ 
										<div class="code-padding"> <span class="comment-code">//...</span> </div>
									];
								</div>
							} <br/> <br/>

							<span class="purple-code">public function</span> <span class="yellow-code">headings</span><span class="code-sign">( )</span> : <span class="code-sign">array</span>
							{
								<div class="code-padding">
									<span class="purple-code">return</span> [ 
										<div class="code-padding"> <span class="comment-code">//...</span> </div>
									];
								</div>
							}
						</div>
					<br/>}
				</div>

				Una vez creada su clase de exportación simplemente agregue la propiedad <span class="label">export</span> a su modelo indicando la clase que debe usar para exportar los datos en un archivo excel ejemplo:

				<div class="code-block">
					<span class="comment-code">// ...</span><br/>
					<span class="purple-code">use </span> App\Exports\<span class="yellow-code">UserExport</span>;<br/><br/>
					<span class="purple-code">class</span> <span class="yellow-code">User</span> <span class="purple-code">extends</span> <span class="green-code">Model</span>
					{
						<div class="code-padding">
							<span class="comment-code">// ...</span><br/>
							<span class="purple-code">public</span> <span class="blue-code">$export</span> <span class="code-sign">=</span> [
								<div class="code-padding">
									<span class="green-code">"instance"</span> <span class="yellow-code">=></span> <span class="blue-code">UserExport</span><span class="code-sign">::</span><span class="yellow-code">class</span>, <span class="comment-code">// clase para exportar datos</span> <br>
									<span class="green-code">"fileName"</span> <span class="yellow-code">=></span> <span class="green-code">"Usuarios.xlsx"</span> <span class="comment-code">// nombre del archivo excel </span>
								</div>
							];<br/>
							<span class="comment-code">// ...</span>
						</div>
					} <br/>
					<span class="comment-code">// ...</span>
				</div>

				Con esto configurado lo unico que tiene que hacer es usar la ruta que apunta a un metodo de su controlador que ya expone el metodo de <span class="label">odataJsonResponse</span> y a esta url debe agregarle el parámetro <span class="label">export</span> para indicarle al <span class="label">OData</span> de que devuelva los datos en un archivo excel ejemplo:

				<div class="cmd-code">
					https://myapi.com/api/users?export
				</div>

				de igual manera puede aplicar, filtros, paginación, ordenamiento de datos y demas para indicarle al <span class="label">OData</span> que datos debe cargar en el archivo excel un ejemplo aplicando un filtro:

				<div class="cmd-code">
					https://myapi.com/api/users?export&filter=role_id:2,state_id:1
				</div>

			</article>

			<article>
				<h1> <span class="item-icon">#</span> Modo personalizado</h1>

				Por ultimo debe saber que no debe sentirse atado a usar el metodo <span class="label">odataJsonResponse</span> y retornarlo directamente desde su controlador, si desea puede usar el metodo <span class="label">odataModelCollection</span> que ya se menciono anteriormente, para obtener unicamente la coleción del modelo con todos los filtros paginación y demas aplicados sobre este. de esta manera usted puede personalizar sus respuestas de la <span class="label">API</span>, los paquete que usa para exportar datos y demas. <br/>
				Este paquete puedes encontrarlo en github como <a href="https://github.com/Gabriel1777/laravel-odata" class="blue-link" target="_blank">Gabriel1777/laravel-odata</a>.
			</article>
		</div>
	</main>
	<script src="https://unpkg.com/vue@next"></script>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/axios/0.21.1/axios.min.js"></script>
	<script src="js/app.js"></script>
</body>
</html>