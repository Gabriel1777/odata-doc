<!DOCTYPE html>
<html>
<head>
	<title>Laravel OData</title>
	<link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet"/>
	<link href="https://fonts.googleapis.com/css?family=Open+Sans&display=swap" rel="stylesheet"/>

	<!-- Robot -->
	<link rel="preconnect" href="https://fonts.googleapis.com">
	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link href="https://fonts.googleapis.com/css2?family=Roboto:ital,wght@0,100;0,300;0,400;1,100;1,300;1,400&display=swap" rel="stylesheet">

	<!-- Lato -->
	<link rel="preconnect" href="https://fonts.googleapis.com">
	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link href="https://fonts.googleapis.com/css2?family=Lato:ital,wght@0,100;0,300;0,400;1,100;1,300&family=Roboto:ital,wght@0,100;0,300;0,400;1,100;1,300;1,400&display=swap" rel="stylesheet">

	<!-- Rubik -->
	<link rel="preconnect" href="https://fonts.googleapis.com">
	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link href="https://fonts.googleapis.com/css2?family=Lato:ital,wght@0,100;0,300;0,400;1,100;1,300&family=Roboto:ital,wght@0,100;0,300;0,400;1,100;1,300;1,400&family=Rubik:ital,wght@0,300;0,400;0,500;1,300;1,400&display=swap" rel="stylesheet">

	<!-- Nunito -->
	<link rel="preconnect" href="https://fonts.googleapis.com">
	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link href="https://fonts.googleapis.com/css2?family=Lato:ital,wght@0,100;0,300;0,400;1,100;1,300&family=Nunito:ital,wght@0,200;0,300;0,400;0,500;1,200;1,300;1,400&family=Roboto:ital,wght@0,100;0,300;0,400;1,100;1,300;1,400&family=Rubik:ital,wght@0,300;0,400;0,500;1,300;1,400&display=swap" rel="stylesheet">


	<link rel="stylesheet" href="css/app.css"/>
	<link rel="stylesheet" href="css/dark.css"/>
	<link rel="stylesheet" href="css/code.css"/>
</head>
<body>
	<main id="my-app">
		<aside class="left-panel">

			<div class="panel-header">
				<div class="container-logo">
					<img src="images/laravel.png" class="laravel-logo"/>
					<span class="logo-divider">+</span>
					<img src="images/odata.png" class="odata-logo"/>
				</div>
				<div class="container-title">
					<h1 class="header-title">Laravel/OData</h1>
				</div>
			</div>

			<div class="panel-body">
				<ul>
					<li class="top-item active1"> 
						<a href="#"> 
							<span class="item-icon">#</span> Introducción
						</a>
					</li>
					<li class="top-item"> 
						<a href="#"> 
							<span class="item-icon">#</span> Instalación
						</a>
					</li>
					<li class="top-item"> 
						<a href="#"> 
							<span class="item-icon">#</span> Integración
						</a>
						<ul>
							<li>
								<a href="#">
									<span class="item-icon">○</span>Cargar metodos
								</a>
							</li>
							<li>
								<a href="#">
									<span class="item-icon">○</span>Crear controladores
								</a>
							</li>
							<li>
								<a href="#">
									<span class="item-icon">○</span>Uso
								</a>
							</li>
						</ul>
					</li>
					<li class="top-item"> 
						<a href="#"> 
							<span class="item-icon">#</span> Transformadores
						</a>
						<ul>
							<li>
								<a href="#">
									<span class="item-icon">○</span>Usando modelos
								</a>
							</li>
							<li>
								<a href="#">
									<span class="item-icon">○</span>Usando clases
								</a>
							</li>
							<li>
								<a href="#">
									<span class="item-icon">○</span>Usando Laravel/fractal
								</a>
							</li>
						</ul>
					</li>
					<li class="top-item"> 
						<a href="#"> 
							<span class="item-icon">#</span> Consultas por defecto
						</a>
					</li>
					<li class="top-item"> 
						<a href="#"> 
							<span class="item-icon">#</span> Serializador
						</a>

						<ul>
							<li>
								<a href="#">
									<span class="item-icon">○</span>Usando modelos
								</a>
							</li>
							<li>
								<a href="#">
									<span class="item-icon">○</span>Usando clases
								</a>
							</li>
						</ul>
					</li>
				</ul>
			</div>

		</aside>

		<div class="doc-main">

			<h1 class="big-logo-title">Laravel/OData V1</h1>
			<div class="big-container-logo">
				<img src="images/laravel.png" class="laravel-logo"/>
				<span class="logo-divider">+</span>
				<img src="images/odata.png" class="odata-logo"/>
			</div>
			<article>
				<br/>
				<h1> <span class="item-icon">#</span> Introducción</h1>
				Protocolo de datos Abiertos para Laravel
				<br/>
				<span class="label">Laravel/OData</span> es un paquete que implementa el protocolo de datos abierto en Laravel 5.8 o superior.
				<br/>
				<span class="label">OData</span> es la mejor forma de implementar <span class="label">API REST</span> en las aplicaciones, es usado por Microsoft en su lenguaje de programación C#. define un conjunto de mejores practicas a la hora de construir una API para que los desarroladores se concentren en la lógica comercial y así poder olvidarse de las preocupaciones por códigos de estado HTTP, convenciones de url, manejo de consultas y demas. <a href="https://www.odata.org/" target="_blank" class="article-link">https://www.odata.org/</a> <br/>
				Este paquete expone una serie de funciones usadas por OData pero adaptadas a la metodologia que usa laravel, para exponer modelos, usar filtros , manejar consultas y demas usando <span class="label">Eloquent</span>.
				<br/>
				Las ventajas que se obtienen al usar un protocolo de datos abiertos a la hora de contruir <span class="label">API Rest</span> es que este agiliza el desarrolo en el backend al evitar el uso de consultas complejas y super anidadas en los controladores, ademas de que esto mantiene limpio los controladores de logica super extensa que daña las buenas practicas al violar el principio de que los modelos deben mantener la logica de negocio y los controladores solo deben devolver datos.
				<br/>
				OData te permite exponer un modelo atravez de un controlador y de esta manera te olvidas de todas las posibles consultas que pueden salir apartir de ese modelo, ya que es posible solicitarle a la API que filtre los datos expuestos por el modelo por uno o varios campos. usando condicionales <span class="label">and</span> u <span class="label">or</span> de está manera se evita tener que programar cada una de las funciones que expone un sistema que pueden llegar a ser muchas.
				<br/>
				tome como ejemplo un modelo de usuarios <span class="label"> App\User</span> este expone las siguientes consultas en su sistema:
				<br/>
				<span class="label circle">○</span> Lista de usuarios.<br/>
				<span class="label circle">○</span> Lista de usuarios que pertenecen a un pais.<br/>
				<span class="label circle">○</span> Lista de usuarios que pertenecen a una ciudad.<br/>
				<span class="label circle">○</span> Lista de usuarios que se registrarón este mes.<br/>
				<span class="label circle">○</span> Lista de usuarios que pertenecen a cierto rol.<br/>
				entre otras ...<br/>
				normalmente usted puede pensar en crear un <span class="label">Endpoint</span> por cada consulta, o filtrar manualmente los usuarios desde una unica ruta basandose en los diferentes parámetros que se le envían a travez de la url.
				<br/>
				uno de los problemas que se tienen al hacer esto es que usted mismo deberá programar la logica para cada consulta ademas de que si tiene un número bastante amplio de consultas solo para el modelo de usuarios. tratar de poner toda la logica en un solo controlador no escala y dañará las practicas de su código al asignar logica demasiado extensa a un controlador.
				<br/>
				Si decide optar por la solución de poner la lógica de cada consulta en una ruta diferente esto solucionará el problema de las malas practicas en sus controladores, pero de igual forma si tiene muchas consultas tendrá un número grande de rutas solo para consultar un solo modelo, en este caso el <span class="label">App\User</span>.
				<br/>
				Con el <span class="label">OData</span> solo tendrá que exponer su modelo <span class="label">App\User</span> o cualquier otro desde un unico controlador y la aplicación o las aplicaciones que consumen está api pueden solicitarle diferentes consultas al modelo de usuarios usando unicamente parámetros por url. de esto se trata el <span class="label">OData</span>, de una <span class="label">API Rest</span> que solamente expone recursos en este caso <span class="label">Modelos</span> y de está manera los desarrolladores solo tienen que preocuparse por consumir los recursos y construir su aplicación en el front.
				<br/>
				Ademas el <span class="label">OData</span> se encarga de otros procesos comunes en las API, como paginación, alinemiento de datos, exportación de datos, relationships, consultas multitabla entre otros ...
				<br/>
			</article>
			<article>
				<h1> <span class="item-icon">#</span> Instalación</h1>
				Para instalar el paquete puede hacerlo usando composer ejecutando el siguiente comando desde su terminal:
				<div class="cmd-code">composer require apilaravelodata/odata</div>
				una vez instalado el paquete asegurese de tener migradas sus tablas en la base de datos:
				<div class="cmd-code">php artisan migrate</div>
				una vez que ya tenga migradas las tablas en la base de datos, el paquete de <span class="label">OData</span> necesitará mapear cada una de sus tablas y almacenar cada uno de los campos en cache, esto se hace para tener un <span class="label">Esquema</span> de la base de datos en cache y evitar realizar consultas a la base de datos para verificar si existen campos que se solictan por la url, de está manera el <span class="label">OData</span> ya tiene un <span class="label">Esquema</span> en cache y puede verificar que campos son validos y cuales no los son usando procesos desde memoria. para crear el <span class="label">Esquema</span> de la base de datos en cache ejecute el siguiente comando:
				<div class="cmd-code">php artisan odata:config</div>
				Tenga en cuenta de que cada vez que modifique algúna de sus tablas agregando uno o mas campos, deberá ejecutar este comando para actualizar la cache del <span class="label">OData</span>.
				<br/>
			</article>

			<article>
				<h1> <span class="item-icon">#</span> Integración</h1>
				<h3># Cargar metodos</h3>
				El siguiente paso que debe hacer es configurar el odata para poder exponerlo desde sus controladores, para esto se recomienda usar un <span class="label">ApiController</span> controlador para su api donde incluya el uso del <span class="label">OData</span>. por ejemplo puede crear un <span class="label">app/Http/Controllers/ApiController.php</span> con el siguiente contenido:

				<div class="code-block">
					<span class="yellow-code"><xmp><?php</xmp></span>
					<div class="code-divider"></div>
					<span class="purple-code">namespace</span>
					<span class="light-code">App\Http\</span><span class="yellow-code">Controllers</span><span class="light-code">;</span>

					<div class="code-divider"></div>

					<span class="purple-code">use</span>
					<span class="yellow-code">ODataResponse</span><span class="light-code">;</span>

					<div class="code-divider"></div>

					<span class="purple-code">class</span>
					<span class="light-code"> ApiController </span>
					<span class="purple-code">extends</span>
					<span class="green-code">Controller</span><br/>
					{
						<div class="code-padding">
							<span class="purple-code">use </span>
							<span class="yellow-code">ODataResponse</span>;
							<br/>
						</div>
					}
				</div>

				Como puedes darte cuenta se trata de una simple clase que hereda a <span class="label">Controller</span> y esta implementa el trait de <span class="label">ODataResponse</span> que se encarga de cargar todos los metodos de <span class="label">OData</span> dentro de la clase.
				<br/><br/>

				<h3># Crear Controladores</h3>

				Una vez ya tenga la clase con los metodos del <span class="label">OData</span> cargados, lo siguiente que debe hacer es agregar esta clase a sus controladores para empezar a usar los metodos expuestos por el <span class="label">OData</span>. para el ejemplo usaremos un <span class="label">app/Http/Controllers/UserController.php</span> controlador con el siguiente contenido:

				<div class="code-block">
					<span class="yellow-code"><xmp><?php</xmp></span>
					<div class="code-divider"></div>

					<span class="purple-code">namespace</span>
					<span class="light-code">App\Http\</span><span class="yellow-code">Controllers</span><span class="light-code">;</span>

					<div class="code-divider"></div>

					<span class="purple-code">use </span>App\Http\Controllers\<span class="yellow-code">ApiController</span>;

					<div class="code-divider"></div>

					<span class="purple-code">class</span>
					<span class="light-code"> UserController </span>
					<span class="purple-code">extends</span>
					<span class="green-code">ApiController</span><br/>
					{
						<div class="code-padding">
							<span class="comment-code">// ...</span>
						</div>
					}
				</div>

				<h3># Uso</h3>

				Ahora simplemente dentro del controlador creamos un metodo index que retorna un <span class="label">odataJsonResponse</span> basado en un modelo de <span class="label">Eloquent</span>.

				<div class="code-block">
					<span class="yellow-code"><xmp><?php</xmp></span>
					<div class="code-divider"></div>

					<span class="purple-code">namespace</span>
					<span class="light-code">App\Http\</span><span class="yellow-code">Controllers</span><span class="light-code">;</span>

					<div class="code-divider"></div>

					<span class="purple-code">use </span>App\Models\<span class="yellow-code">User</span>;
					<div class="code-divider"></div>
					<span class="purple-code">use </span>App\Http\Controllers\<span class="yellow-code">ApiController</span>;

					<div class="code-divider"></div>

					<span class="purple-code">class</span>
					<span class="light-code"> UserController </span>
					<span class="purple-code">extends</span>
					<span class="green-code">ApiController</span><br/>
					{
						<div class="code-padding">
							<span class="purple-code">public function </span> index <span class="code-sign">( )</span> <br/>
							{
								<div class="code-padding">
									<span class="purple-code">return </span>
									<span class="blue-code">$this</span><span class="code-sign">-></span><span class="yellow-code">odataJsonResponse</span><span class="code-sign">(</span>
									<span class="purple-code">new </span><span class="code-sign">User</span>( )<span class="code-sign"> )</span>;
								</div>
							}
						</div>
					}
				</div>

				Por ultimo es importante que establesca la propiedad <span class="label">table</span> dentro de su modelo como <span class="label">public</span>. esta propiedad la usa el <span class="label">OData</span> para identificar la tabla a la cual hace referencia el modelo.

				<div class="code-block">
					<span class="comment-code">// ...</span>
					<div class="code-divider"></div>
					<span class="purple-code">class</span> <span class="yellow-code">User</span> <span class="purple-code">extends</span> <span class="green-code">Model</span>
					{
						<div class="code-padding">
							<span class="comment-code">// ...</span><br/>
							<span class="purple-code">public</span> <span class="blue-code">$table</span> <span class="code-sign">=</span> <span class="green-code">"users"</span>;
						</div>
					} <br/>
				</div>

				Listo, esto es lo que necesitamos para implementar el <span class="label">OData</span> en una aplicación de laravel. lo siguiente que debes hacer es crear una ruta que apunte al metodo index de tu controlador y una vez realices una solicitud HTTP a esta ruta el <span class="label">OData</span> ya se encargará de generar la estructura de la respuesta en json, el código de estado HTTP junto con la colección de datos. un ejemplo de respuesta sería esta:

				<div class="code-block">
					{
						<div class="code-padding">
							<span class="green-code">"data"</span> : [
							<div class="code-padding">
								<span class="green-code">"data"</span> : [
									<div class="code-padding">
										{
											<div class="code-padding">
												<span class="green-code">"id"</span> : <span class="code-sign">1</span>,<br/>
												<span class="green-code">"name"</span> : <span class="green-code">"example user"</span><br/>
												<span class="comment-code">// ...rest</span>
											</div>
										}, <br/>
										{
											<div class="code-padding">
												<span class="green-code">"id"</span> : <span class="code-sign">2</span>,<br/>
												<span class="comment-code">// ...rest</span>
											</div>
										}
									</div>
								], <br/>
								<span class="green-code">"length"</span> : <span class="code-sign">2</span> <span class="comment-code">// número de registro en la colección</span>
							</div>
							],<br/>
							<span class="green-code">"code"</span> : <span class="yellow-code">200</span>
						</div>
					}
					</span>
				</div>

				Esta es la estructura que por defecto se devolverá para serializar las respuestas de la API, si desea modificarla puede obtener el resultado que devuelve el <span class="label">odataJsonResponse</span> y luego armar un array con base en los valores que obtuvo. y de está manera puede agregar propiedades adicionales que necesite retornar en cada una de las repuestas de su API.
				<br/>
				Otra opción que tiene es usar el metodo <span class="label">odataModelCollection</span> que devuelve la coleción de datos del modelo, igualmente esta coleción toma los filtros que se le indiquen a la <span class="label">API</span> por la url. esto lo puede usar para personalizar la respuesta de su api pero mantienendo el uso del <span class="label">OData</span> en su modelo. también puede agregarle a su respuesta el <span class="label">odataProperties</span> metodo que se encarga de devolver un array con los valores de la respuesta como: código de estado HTTP, cantidad de datos encontrados en la respuesta y demas.

				<div class="code-block">
					<span class="yellow-code"><xmp><?php</xmp></span>
					<div class="code-divider"></div>

					<span class="purple-code">namespace</span>
					<span class="light-code">App\Http\</span><span class="yellow-code">Controllers</span><span class="light-code">;</span>

					<div class="code-divider"></div>

					<span class="purple-code">use </span>App\Models\<span class="yellow-code">User</span>;
					<div class="code-divider"></div>
					<span class="purple-code">use </span>App\Http\Controllers\<span class="yellow-code">ApiController</span>;

					<div class="code-divider"></div>

					<span class="purple-code">class</span>
					<span class="light-code"> UserController </span>
					<span class="purple-code">extends</span>
					<span class="green-code">ApiController</span><br/>
					{
						<div class="code-padding">
							<span class="purple-code">public function </span> index <span class="code-sign">( )</span> <br/>
							{
								<div class="code-padding">
									<span class="purple-code">return </span> [
										<div class="code-padding">
											<span class="green-code">"collection"</span> <span class="yellow-code"> => </span>
											<span class="blue-code">$this</span><span class="code-sign">-></span><span class="yellow-code">odataModelCollection</span><span class="code-sign">(</span>
											<span class="purple-code">new </span><span class="code-sign">User</span>( )<span class="code-sign"> )</span>,<br/>
											<span class="green-code">"api_info"</span> <span class="yellow-code"> => </span>
											<span class="blue-code">$this</span><span class="code-sign">-></span><span class="yellow-code">odataProperties</span><span class="code-sign">(</span>
											<span class="purple-code">new </span><span class="code-sign">User</span>( )<span class="code-sign"> )</span>,<br/>
											<span class="comment-code">// ...</span>
										</div>
									];
								</div>
							}
						</div>
					}
				</div>
			</article>

			<article>
				<h1> <span class="item-icon">#</span> Transformadores</h1>
				Los transformadores se usan para estructurar cada uno de los objetos que se devuelven en las colecciónes de cada una de las respuestas de la API, en el caso del modelo de usuarios el <span class="label">OData</span> por defecto devolverá la colección que devuelve laravel en sus colecciones por ejemplo al llamar un <span class="label">User::all()</span>.
				<br/><br/>
				<h3># Usando modelos </h3>
				otra caracteristica que tiene el <span class="label">OData</span> es que por defecto devolverá la coleción completa sin ningún tipo de filtro ni paginación. esto obviamente se puede solicitar desde la url, pero el punto aquí es que devolver todos los datos del modelo puede no ser lo que usted tiene planeado. por ejemplo no queremos que la contraseña del usuario se vea en la respuesta de la API, o puede que necesitemos agregar otras propiedades mas al modelo con información adicional que no necesariamente debe estar almacenada en la base de datos. <br/>
				para esto se puede usar un transformador personalizado desde el módelo, lo unico que tiene que hacer es declarar un <span class="label">transform</span> metodo dentro del modelo que devuelva un array. si el <span class="label">OData</span> detecta que existe este metodo dentro del modelo lo usará para serializar los objetos que se devuelven en la coleción de datos.
				<br/>
				esto puede ser util para asegurarse de que la respuesta devuelva unicamente los datos que usted necesita incluyendo otros datos adicionales ejemplo:

				<div class="code-block">
					<span class="comment-code">// ...</span>
					<div class="code-divider"></div>
					<span class="purple-code">class</span> <span class="yellow-code">User</span> <span class="purple-code">extends</span> <span class="green-code">Model</span><br/>
					{
						<div class="code-padding">
							<span class="comment-code">// ...</span><br/>
							<span class="purple-code">public function</span> transform <span class="code-sign">( )</span><br/>
							{
								<div class="code-padding">
									<span class="purple-code">return</span> [
										<div class="code-padding">
											<span class="green-code">"id"</span> <span class="yellow-code">=></span> <span class="blue-code">$this</span><span class="code-sign">-></span>id,<br/>
											<span class="green-code">"name"</span> <span class="yellow-code">=></span> <span class="blue-code">$this</span><span class="code-sign">-></span>name,<br/>
											<span class="green-code">"role"</span> <span class="yellow-code">=></span> <span class="blue-code">$this</span><span class="code-sign">-></span>role_id,<br/>
											<span class="green-code">"photo"</span> <span class="yellow-code">=></span> <span class="blue-code">$this</span><span class="code-sign">-></span><span class="yellow-code">getPhoto<span class="code-sign">( )</span><br/>
										</div>
									];
								</div>
							}
							<br/><span class="comment-code">// ...</span>
						</div>
					}
					<br/><span class="comment-code">// ...</span>
				</div>
				<h3># Usando clases </h3>
				Puede que la lógica de su transformador sea mucho mas robusta y necesite tener varios metodos que retornan un resultado procesado para agregarlo como una propiedad en cada uno de los objetos de la coleción. en este caso no es una buena idea asignar toda esta lógica al modelo y lo mejor es separar la lógica de la transformación de datos en una clase por separado.<br/>
				puede hacer esto creando una clase común y corriente con un metodo <span class="label">transform</span> que devuelva un array con los datos que desea mostrar por objeto, y puede usar el resto de la clase para agregar metodos que menejen y procesen la logica que necesita para las propiedades adicionales de su modelo ejemplo:

				<div class="code-block">
					<span class="purple-code">namespace </span> App\Transformers;<br/><br/>
					<span class="purple-code">class</span> <span class="yellow-code">UserTransformer</span><br/>
					{
						<div class="code-padding">
							<span class="purple-code">public function</span> getPhoto <span class="code-sign">( <span class="blue-code">$user</span> )</span><br/>
							{
								<div class="code-padding">
									<span class="comment-code">// your code ...</span>
								</div>
							}
						</div>

						<div class="code-padding">
							<span class="purple-code">public function</span> transform <span class="code-sign">( <span class="blue-code">$user</span> )</span><br/>
							{
								<div class="code-padding">
									<span class="purple-code">return</span> [<br/>
										<div class="code-padding">
											<span class="green-code">"id"</span> <span class="yellow-code"> => </span> <span class="blue-code">$user</span><span class="code-sign">-></span>id,<br/>
											<span class="green-code">"name"</span> <span class="yellow-code"> => </span> <span class="blue-code">$user</span><span class="code-sign">-></span>name,<br/>
											<span class="green-code">"role"</span> <span class="yellow-code"> => </span> <span class="blue-code">$user</span><span class="code-sign">-></span>role_id,<br/>
											<span class="green-code">"photo"</span> <span class="yellow-code"> => </span> <span class="blue-code">$this</span><span class="code-sign">-></span>getPhoto<span class="code-sign"> ( <span class="blue-code">$user</span> ),<br/>
										</div>
									];
								</div>
							}
						</div>
					}
				</div>

				Una vez ya creada la clase con la lógica del transformador deberá agregar la propiedad <span class="label">transformer</span> a su modelo para indicarle al <span class="label">OData</span> que use esta clase para serializar los objetos de la coleción que irá en la respuesta:

				<div class="code-block">
					<span class="comment-code">// ...</span><br/>
					<span class="purple-code">class</span> <span class="yellow-code">User</span> <span class="purple-code">extends</span> <span class="green-code">Model</span>
					{
						<div class="code-padding">
							<span class="comment-code">// ...</span><br/>
							<span class="purple-code">public</span> <span class="blue-code">$transformer</span> <span class="code-sign">=</span> <span class="green-code">"App\Transformers\UserTransformer"</span>;<br/>
							<span class="comment-code">// ...</span>
						</div>
					} <br/>
					<span class="comment-code">// ...</span>
				</div>

				<h3># Usando Laravel/Fractal</h3>
				<span class="label">Laravel/Fractal</span> ya ofrece una librería para transformar datos <a target="_blank" class="article-link" href="https://fractal.thephpleague.com/transformers/">https://fractal.thephpleague.com/transformers/</a>, <span class="label">Laravel/OData</span> es compatible con este caso de uso. puede agregar la propiedad <span class="label">transformer</span> igualmente en su modelo especificando en lugar de una clase común una clase de transformador.

				<div class="code-block">
					<span class="purple-code">use </span> App\Transformers\<span class="yellow-code">UserTransformer</span>;
					<div class="code-divider"></div>
					<span class="purple-code">class</span> <span class="yellow-code">User</span> <span class="purple-code">extends</span> <span class="green-code">Model</span>
					{
						<div class="code-padding">
							<span class="comment-code">// ...</span><br/>
							<span class="purple-code">public</span> <span class="blue-code">$transformer</span> <span class="code-sign">=</span> <span class="yellow-code">UserTransformer</span><span class="code-sign">::</span><span class="blue-code">class</span>;<br/>
							<span class="comment-code">// ...</span>
						</div>
					} <br/>
				</div>
			</article>

			<article>
				<h1> <span class="item-icon">#</span> Consultas por defecto </h1> 
				Conociendo que el <span class="label">OData</span> devuelve todos los datos del modelo sin nigún tipo de filtro, es lógico pensar que puede que esto no se ajuste a su caso de uso.
				puede que necesite ocultar cierta información a sus usuarios dependiendo del rol que tengan asignado, un ejemplo pordría ser las lista de ordenes donde cada usuario solo puede consultar las ordenes que ha realizado junto con su historial. y en el caso de tratarse del administrador este puede ver todas las ordenes.
				<div class="divider"></div>
				<h3># Usando un scope</h3>
				puede definir la consulta por defecto que manejará el <span class="label">OData</span> declarando un <span class="label">scope</span> dentro de su modelo, el <span class="label">scope</span> en este caso deberá llamarse <span class="label">defaultQuery</span> y este debe retornar una consulta. si el <span class="label">OData</span> detecta que este scope existe dentro del modelo, aplicará por defecto la consulta que devuelve el <span class="label">scope</span> a la colección en la respuesta de la API.

				<div class="code-block">
					<span class="purple-code">class</span> <span class="yellow-code">Order</span> <span class="purple-code">extends</span> <span class="green-code">Model</span> <br/>
					{
						<div class="code-padding">
							<span class="comment-code">// ...</span> <br/>
							<span class="purple-code">public function </span> <span class="yellow-code">scopeDefaultQuery</span> <span class="code-sign">( <span class="blue-code">$query</span> )</span> <br/>
							{
								<div class="code-padding">
									<span class="purple-code">if</span> <span class="code-sign">( <span class="light-code">auth</span>( )-><span class="light-code">user</span>( )-><span class="blue-code">isAdmin</span>( ) )</span><br/>
									{
										<div class="code-padding">
											<span class="purple-code">return </span> <span class="blue-code">$query</span>;
										</div>
									} <span class="purple-code">else</span> {
										<div class="code-padding">
											<span class="purple-code">return </span> <span class="blue-code">$query</span>-><span class="yellow-code">where</span><span class="code-sign">( <span class="green-code">"user_id"</span> <span class="light-code">, auth</span>( )-><span class="light-code">user</span>( )-><span class="light-code">id</span> )</span>;
										</div>
									}
								</div>
							}		
						</div>
					}
				</div>

				Los desarroladores que consuman su <span class="label">API</span> igualmente pueden filtrar la coleción desde la url, pero si aplico la consulta por defecto desde su modelo solo podrán filtrar los datos apartir del resultado por defecto que se le indico al <span class="label">OData</span>. no podrán deshacer el filtro por defecto desde la url, solo podrán agregar mas filtros apartir del que ya está definido.
			</article>

			<article>
				<h1> <span class="item-icon">#</span> Serializador </h1>
				Si bien usar transformadores es una buena idea para armar los objectos de la coleción en sus respuestas de la <span class="label">API</span> puede ver se en el problema de <a href="https://stackoverflow.com/questions/97197/what-is-the-n1-selects-problem-in-orm-object-relational-mapping" target="_blank" class="article-link">N+1</a> que es muy común a la hora de trabajar con un <span class="label">ORM</span>. este problema le puede causar retrazos de velocidad en las repuestas de su <span class="API">API</span> si no tiene en cuenta el número de consultas que realiza a la base de datos por cada objeto.<br/>
				si tiene una colección de 50 usuarios y en el transformador de cada objeto llama a el rol, el estado, la cuidad, el departamento y su subscripción actual, y esto lo hace por cada usuario tendrá un resultado de <span class="label">50 * 5</span> = <span class="label">250</span> consultas a su base de datos lo que puede volver lenta la respuesta de la API.<br/>
				si bien laravel ya nos ofrecen una solución usando el metodo <span class="label">with</span> que ya viene con <span class="label">Eloquent</span> y este se encarga de realizar las consultas a la base de datos necesarias para armar su colección y luego la arma desde memoria, para el ejemplo anterior esto va ir reduciendo el número de consultas de <span class="label"> 250 </span> a <span class="label">6</span>. igual debe saber que entre mas compleja sea la consulta mas dificil será de mantener usando un <span class="label">ORM</span> por lo que en casos complejos es mejor optar por utilizar <span class="label">Consultas multitabla, Vistas o Procedimientos almacenados</span>. sin embargo puede hacer uso del scope <span class="label">defaultQuery</span> del <span class="label">OData</span> para llamar el metodo with de eloquent si así lo requiere:

				<div class="code-block">
					<span class="purple-code">class</span> <span class="yellow-code">User</span> <span class="purple-code">extends</span> <span class="green-code">Model</span> <br/>
					{
						<div class="code-padding">
							<span class="comment-code">// ...</span> <br/>
							<span class="purple-code">public function </span> <span class="yellow-code">scopeDefaultQuery</span> <span class="code-sign">( <span class="blue-code">$query</span> )</span> <br/>
							{
								<div class="code-padding">
									<span class="blue-code">$query</span> = <span class="blue-code">$query</span>-><span class="yellow-code">with</span><span class="code-sign">(
										<span class="green-code">"role"</span>,
										<span class="green-code">"state"</span>,
										<span class="green-code">"city.department"</span>,
										<span class="green-code">"subscriptions"</span>
									);</span> <br/>
									<span class="purple-code">if</span> <span class="code-sign">( <span class="light-code">auth</span>( )-><span class="light-code">user</span>( )-><span class="blue-code">isAdmin</span>( ) )</span><br/>
									{
										<div class="code-padding">
											<span class="purple-code">return </span> <span class="blue-code">$query</span>;
										</div>
									} <span class="purple-code">else</span> {
										<div class="code-padding">
											<span class="purple-code">return </span> <span class="blue-code">$query</span>-><span class="yellow-code">where</span><span class="code-sign">( <span class="green-code">"user_id"</span> <span class="light-code">, auth</span>( )-><span class="light-code">user</span>( )-><span class="light-code">id</span> )</span>;
										</div>
									}
								</div>
							}		
						</div>
					}
				</div>

				<h3># Usando modelos</h3>

				Si bien el metodo <span class="label">with</span> nos ahorra el tener que hacer las consultas a la base de datos una por una y por cada objeto, esto no será util si se encuentra con una consulta compleja que relaciona muchas tablas, en estos casos tenga en cuenta que si su transformador tiene un metodo que hace 10 o mas consultas a la base de datos y eso lo hacer por cada objeto, puede verse en un problema de velocidad en su respuesta. <br/>
				Para esto puede especificar un serializador dentro de su modelo declarando un metodo llamado <span class="label">collectionSerializer</span>, si el <span class="label">OData</span> detecta que este metodo existe en su modelo lo usará para serializar la colección antes de pasarselo al transformador. puede usar esta ventaja para realizar allí las consultas que necesita a su base de datos e ir armando la colección y una vez armada simplemente se la pasamos a los transformadores.<br/>
				de está manera los transformadores ya no se verán obligados a realizar consultas por cada objeto si no simplemente a pintar las propiedades que ya vienen en la colección. un ejemplo de esto podría ser llamar un procedimiento almacenado o una consulta multitabla que devuelva todos los campos de las tablas que se necesitan en la consulta e ir armando la coleción con base en estos valores ejemplo:

				<div class="code-block">
					<span class="comment-code">// ...</span><br/>
					<span class="purple-code">class</span> <span class="yellow-code">User</span> <span class="purple-code">extends</span> <span class="green-code">Model</span><br/>
					{
						<div class="code-padding">
							<span class="comment-code">// ...</span><br/>
							<span class="purple-code">public function</span> <span class="yellow-code">collectionSerializer</span><span class="code-sign">( <span class="blue-code">$collection</span> )</span><br/>
							{
								<div class="code-padding">
									<span class="comment-code">/* llamamos una consulta multitabla compleja que nos devuelva en una sola transacción un calculo procesado.
									 en este caso pedimos la cantidad de suscripciones que ha comprado el usuario en el ultimo año.
									 bueno puede que en realidad esta consulta no sea tan compleja entonces piensa en una consulta mas complicada :v <br/>
									 el punto es que aquí en el serializador se hace una sola consulta a la base de datos que ya nos trae todos los datos que necesitamos 
									 entonces simplemente le asignamos esos valores a la coleción que nos pasa el OData y ya cuando pase por el transformador no se harán mas consultas a la DB.
									  */<br/>
									</span><br/>
									<span class="blue-code">$query </span> = 
									<span class="yellow-code">collect</span><span class="code-sign"></span><span class="code-sign">(</span> \<span class="blue-code">DB</span><span class="code-sign">::<span class="yellow-code">select</span>(
										<span class="green-code">"select users.id as 'user_id', subscriptions.* , user_subscriptions.quantity_subscriptions from users, subscriptions, user_subscriptions where ..."</span>
									) )</span>;
									<br/>
									<span class="blue-code">$users</span> = <span class="blue-code">$collection</span>-><span class="blue-code">map</span><span class="code-sign">(
										<span class="purple-code">function</span> ( <span class="blue-code">$user</span> ) <span class="purple-code">use</span> ( <span class="blue-code">$query</span> ) {
										<div class="code-padding">
											<span class="comment-code">
												/*la consulta nos devuelve una propiedad con el nombre quantity_subscriptions, cada modelo de usuarios no trae esta propiedad entonces
												iteramos la colección y  vamos asignando esta propiedad a cada uno de los usuarios de la colección que nos paso el OData por parámetro en el metodo.
												usando los resultados de la consulta compleja que acabamos de hacer.<br/>
												de esta manera los transformadores ya no tendrán que hacer consultas a la base de datos para obtener esta propiedad por que ya viene en la coleción.
												*/
											</span><br/>
											<span class="blue-code">$user</span><span class="light-code">->quantity_subscriptions =</span> <span class="blue-code">$query</span>-><span class="yellow-code">where</span><span class="code-sign">( <span class="green-code">"user_id"</span> , <span class="blue-code">$user</span><span class="light-code">->id</span> )</span><span class="light-code">->quantity_subscriptions;</span>
											<br/>
											<span class="purple-code">return</span> <span class="blue-code">$user</span>;
										</div>
									} )</span>;<br/>
									<span class="purple-code">return</span> <span class="blue-code">$users</span>;
								</div>
							}<br/>
							<span class="comment-code">// ...</span>
						</div>
					}
				</div>

				<h3># Usando clases</h3>

				Si no desea asignar la logica del serializador a su modelo, puede igualmente usar una clase para personalizar este trabajo, solo tiene que crear una clase común que tenga igualmente un metodo llamado <span class="label">collectionSerializer</span>. esto le sirve para trabajar con multiples metodos dentro de su clase y separar la logica de serialización de datos de su modelo. 

				<div class="code-block">
					<span class="purple-code">namespace</span> App\Serializers; <br/><br/>
					<span class="purple-code">class</span> <span class="yellow-code">UserSerializer</span><br/>
					{
						<div class="code-padding">
							<span class="comment-code">// ...</span><br/>
							<span class="purple-code">public function</span> <span class="yellow-code">collectionSerializer</span><span class="code-sign">( <span class="blue-code">$collection</span> )</span><br/>
							{
								<div class="code-padding">
									<span class="blue-code">$query </span> = 
									<span class="yellow-code">collect</span><span class="code-sign"></span><span class="code-sign">(</span> \<span class="blue-code">DB</span><span class="code-sign">::<span class="yellow-code">select</span>(
										<span class="green-code">"select users.id as 'user_id', subscriptions.* , user_subscriptions.quantity_subscriptions from users, subscriptions, user_subscriptions where ..."</span>
									) )</span>;
									<br/>
									<span class="blue-code">$users</span> = <span class="blue-code">$collection</span>-><span class="blue-code">map</span><span class="code-sign">(
										<span class="purple-code">function</span> ( <span class="blue-code">$user</span> ) <span class="purple-code">use</span> ( <span class="blue-code">$query</span> ) {
										<div class="code-padding">
											<span class="blue-code">$user</span><span class="light-code">->quantity_subscriptions =</span> <span class="blue-code">$query</span>-><span class="yellow-code">where</span><span class="code-sign">( <span class="green-code">"user_id"</span> , <span class="blue-code">$user</span><span class="light-code">->id</span> )</span><span class="light-code">->quantity_subscriptions;</span>
											<br/>
											<span class="purple-code">return</span> <span class="blue-code">$user</span>;
										</div>
									} )</span>;<br/>
									<span class="purple-code">return</span> <span class="blue-code">$users</span>;
								</div>
							}<br/>
							<span class="comment-code">// ...</span>
						</div>
					}
				</div>

				Una vez construida su clase deberá asignar la propiedad <span class="label">serializer</span> a su modelo especificando la clase que debe usar para serializar las colecciones de datos. si especifico esta propiedad en su modelo el <span class="label">OData</span> la usará para serializar los datos de su colección.

				<div class="code-block">
					<span class="comment-code">// ...</span><br/>
					<span class="purple-code">class</span> <span class="yellow-code">User</span> <span class="purple-code">extends</span> <span class="green-code">Model</span>
					{
						<div class="code-padding">
							<span class="comment-code">// ...</span><br/>
							<span class="purple-code">public</span> <span class="blue-code">$serializer</span> <span class="code-sign">=</span> <span class="green-code">"App\Serializers\UserSerializer"</span>;<br/>
							<span class="comment-code">// ...</span>
						</div>
					} <br/>
					<span class="comment-code">// ...</span>
				</div>

			</article>
		</div>
	</main>
	<script src="https://unpkg.com/vue@next"></script>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/axios/0.21.1/axios.min.js"></script>
	<script src="js/app.js"></script>
</body>
</html>